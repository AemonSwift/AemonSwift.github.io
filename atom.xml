<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>长亭短亭</title>
  
  <subtitle>Man Propose, God Dispose.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://aemonswift.github.io/"/>
  <updated>2019-11-06T02:23:19.070Z</updated>
  <id>http://aemonswift.github.io/</id>
  
  <author>
    <name>AemonSwift</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>区块链简介</title>
    <link href="http://aemonswift.github.io/2019/11/06/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%AE%80%E4%BB%8B/"/>
    <id>http://aemonswift.github.io/2019/11/06/区块链简介/</id>
    <published>2019-11-06T02:23:19.000Z</published>
    <updated>2019-11-06T02:23:19.070Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>tidb简介</title>
    <link href="http://aemonswift.github.io/2019/11/06/tidb/"/>
    <id>http://aemonswift.github.io/2019/11/06/tidb/</id>
    <published>2019-11-06T02:18:15.000Z</published>
    <updated>2019-11-06T02:18:15.801Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>rust语言使用教程</title>
    <link href="http://aemonswift.github.io/2019/11/06/rust%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://aemonswift.github.io/2019/11/06/rust语言使用教程/</id>
    <published>2019-11-06T01:39:50.000Z</published>
    <updated>2019-11-06T01:39:50.030Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>tidb数据库的简介</title>
    <link href="http://aemonswift.github.io/2019/11/06/tidb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%AE%80%E4%BB%8B/"/>
    <id>http://aemonswift.github.io/2019/11/06/tidb数据库的简介/</id>
    <published>2019-11-06T01:39:34.000Z</published>
    <updated>2019-11-06T01:48:54.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://blog.csdn.net/uisoul/article/details/85219016" target="_blank" rel="noopener">遇见 TiDB，放弃MySQL</a><br><a href="https://blog.csdn.net/m0_37683758/article/details/86738403" target="_blank" rel="noopener">TiDB和Mysql的sql差异总结</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/uisoul/article/details/85219016
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>拖拽排序后端设计与实现</title>
    <link href="http://aemonswift.github.io/2019/11/05/%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F%E5%90%8E%E7%AB%AF%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://aemonswift.github.io/2019/11/05/拖拽排序后端设计与实现/</id>
    <published>2019-11-05T01:09:27.000Z</published>
    <updated>2019-11-05T01:10:07.653Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.jianshu.com/p/9ee708e43ebf" target="_blank" rel="noopener">拖拽排序后端设计与实现</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/9ee708e43ebf&quot; target=&quot;_blan
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>mysql读写分离到CQRS</title>
    <link href="http://aemonswift.github.io/2019/11/05/mysql%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%88%B0CQRS/"/>
    <id>http://aemonswift.github.io/2019/11/05/mysql读写分离到CQRS/</id>
    <published>2019-11-05T01:02:37.000Z</published>
    <updated>2019-11-06T01:20:10.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL读写分离"><a href="#MySQL读写分离" class="headerlink" title="MySQL读写分离"></a>MySQL读写分离</h1><p>随着技术的发展，在实际的生产环境中，由单台MySQL数据库服务器不能满足实际的需求。此时数据库集群就很好的解决了这个问题。采用MySQL分布式集群，能够搭建一个高并发、负载均衡的集群服务器。在此之前我们必须要保证每台MySQL服务器里的数据同步。数据同步我们可以通过MySQL内部配置就可以轻松完成，主要有主从复制和主主复制。<br>　MySQL数据库自身提供的主从复制功能可以方便的实现数据的多处自动备份，实现数据库的拓展。多个数据备份不仅可以加强数据的安全性，通过实现读写分离还能进一步提升数据库的负载性能。<br>在一主多从的数据库体系中，多个从服务器采用异步的方式更新主数据库的变化，业务服务器在执行写或者相关修改数据库的操作是在主服务器上进行的，读操作则是在各从服务器上进行。如果配置了多个从服务器或者多个主服务器又涉及到相应的负载均衡问题，关于负载均衡具体的技术细节还没有研究过，今天就先简单的实现一主一从的主从复制功能。</p><h2 id="为什么需要主从复制"><a href="#为什么需要主从复制" class="headerlink" title="为什么需要主从复制"></a>为什么需要主从复制</h2><ol><li>读写分离。在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。</li><li>做数据的热备</li><li>架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。</li></ol><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://blog.csdn.net/why15732625998/article/details/80463041" target="_blank" rel="noopener">MySQL主从复制及读写分离实战</a><br><a href="https://www.jianshu.com/p/1b82a1f6a586" target="_blank" rel="noopener">读写分离到CQRS</a><br><a href="http://tech.it168.com/a2018/0822/5010/000005010149.shtml" target="_blank" rel="noopener">数据库的这些性能优化，你做了吗？</a><br><a href="https://www.cnblogs.com/cnmenglang/p/6393769.html" target="_blank" rel="noopener">深入解析Mysql 主从同步延迟原理及解决方案</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL读写分离&quot;&gt;&lt;a href=&quot;#MySQL读写分离&quot; class=&quot;headerlink&quot; title=&quot;MySQL读写分离&quot;&gt;&lt;/a&gt;MySQL读写分离&lt;/h1&gt;&lt;p&gt;随着技术的发展，在实际的生产环境中，由单台MySQL数据库服务器不能满足实际的需求。
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>mysql之范式</title>
    <link href="http://aemonswift.github.io/2019/11/04/mysql%E4%B9%8B%E8%8C%83%E5%BC%8F/"/>
    <id>http://aemonswift.github.io/2019/11/04/mysql之范式/</id>
    <published>2019-11-04T11:17:19.000Z</published>
    <updated>2019-11-07T09:55:41.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么存在范式"><a href="#为什么存在范式" class="headerlink" title="为什么存在范式"></a>为什么存在范式</h1><p>引入范式的目的主要是解决数据冗余问题。<br>例如：<br><img alt="订单综述表" data-src="https://cdn.jsdelivr.net/gh/AemonSwift/AemonSwift@latest/AemonSwift.github.io/images/mysql%E8%8C%83%E5%BC%8F1.png" class="lozad"><br>数据库看上去像一个表格，其实不然，比如如下的订单表，一个订单号X2001对应一个用户，但是还对应了两行产品，非常不规范。<br>要想把这个表规范化，可以使用范式。</p><h1 id="第一范式——字段是不可再分"><a href="#第一范式——字段是不可再分" class="headerlink" title="第一范式——字段是不可再分"></a>第一范式——字段是不可再分</h1><p>即不存在一个字段中存在两个及以上值的情况。<br>在上述例子中，为了规范话，我们可以进行拆分两个表格。<br>一个是订单表：一个订单号可以唯一的确定一行<br><img alt="订单表" data-src="https://cdn.jsdelivr.net/gh/AemonSwift/AemonSwift@latest/AemonSwift.github.io/images/mysql%E8%8C%83%E5%BC%8F12png" class="lozad"><br>一个是细节表：一个订单号+产品编码才可以唯一的确定一行。<br><img alt="细节表" data-src="https://cdn.jsdelivr.net/gh/AemonSwift/AemonSwift@latest/AemonSwift.github.io/images/mysql%E8%8C%83%E5%BC%8F3.png" class="lozad"><br>所以我们说订单表的主键是 （订单号）， 细节表的主键是（订单号，产品编码）， 这是一个复合主键。</p><h1 id="第二范式——所有属性都依赖于主键"><a href="#第二范式——所有属性都依赖于主键" class="headerlink" title="第二范式——所有属性都依赖于主键"></a>第二范式——所有属性都依赖于主键</h1><p>即把其它不想关的字段都拆分出去。<br>再看看订单细节表， 产品名称和单价实际上并不依赖于订单号。如果想添加一个新的产品， 你会发现没法放入这张表， 因为没有订单号！<br><img alt="细节表" data-src="https://cdn.jsdelivr.net/gh/AemonSwift/AemonSwift@latest/AemonSwift.github.io/images/mysql%E8%8C%83%E5%BC%8F4.png" class="lozad"><br>所以还需要进行拆分<br><img alt="拆分后的表" data-src="https://cdn.jsdelivr.net/gh/AemonSwift/AemonSwift@latest/AemonSwift.github.io/images/mysql%E8%8C%83%E5%BC%8F5.png" class="lozad"><br>拆分以后，表4.1订单细节表的主键还是（订单号，产品编码），但是剩下的属性（数量）肯定是完全依赖于主键的。表4.2产品表也类似，主键是产品编码，剩下的属性都依赖于产品编码</p><h2 id="不满足第二范式存在如下问题"><a href="#不满足第二范式存在如下问题" class="headerlink" title="不满足第二范式存在如下问题"></a>不满足第二范式存在如下问题</h2><ol><li>数据冗余：同个用户可以产生n个订单，用户的名称重复了n-1次</li><li>更新异常：若用户更改自己的名称时，数据表关于此用户所在行的名称都要更新，否则导致用户名称不一致性。</li><li>插入异常：若出现一个新用户时，用户只来注册。不来买东西，则这个用户是无法插入到数据库中。</li><li>删除异常：一批用户已完成产品的买入，这些记录应该从数据库表中删除。但删除时导致用户的信息也删除。</li></ol><h1 id="第三范式——消除依赖传递-属性不依赖于其它非主属性"><a href="#第三范式——消除依赖传递-属性不依赖于其它非主属性" class="headerlink" title="第三范式——消除依赖传递(属性不依赖于其它非主属性)"></a>第三范式——消除依赖传递(属性不依赖于其它非主属性)</h1><p>我们再回过头来看一下表格3 订单表，它的主键是订单号，所有的属性都依赖于主键，已经是第二范式。 但是我们发现，订单号能决定用户ID，用户ID能决定用户名称，这就出现了依赖传递：$\color{red}{订单号-&gt;用户ID-&gt;用户名称}$。<br><img alt="依赖传递表" data-src="https://cdn.jsdelivr.net/gh/AemonSwift/AemonSwift@latest/AemonSwift.github.io/images/mysql%E8%8C%83%E5%BC%8F6.png" class="lozad"><br>进行拆分：<br><img alt="拆分表" data-src="https://cdn.jsdelivr.net/gh/AemonSwift/AemonSwift@latest/AemonSwift.github.io/images/mysql%E8%8C%83%E5%BC%8F7.png" class="lozad"></p><h2 id="不满足第二范式存在如下问题-1"><a href="#不满足第二范式存在如下问题-1" class="headerlink" title="不满足第二范式存在如下问题"></a>不满足第二范式存在如下问题</h2><ol><li>数据冗余：</li><li>更新异常：</li><li>插入异常：</li><li>删除异常：</li></ol><h1 id="BC范式——消除非主属性对任一一个候选键依赖"><a href="#BC范式——消除非主属性对任一一个候选键依赖" class="headerlink" title="BC范式——消除非主属性对任一一个候选键依赖"></a>BC范式——消除非主属性对任一一个候选键依赖</h1><p>例如：<br>仓库管理表，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品<br>仓库|    管理员    |物品类型    |数目<br>:-:|:-:|:-:|:-:<br>1    |刘老师|    物品A|    10<br>1|    刘老师|    物品B|    15<br>2|    王老师    |物品B|    20<br>2    |王老师|    物品C|    10<br>… …    |… …    |… …    |… …<br>表中候选键有：(仓库，物品类型)和(管理员，物品类型)，由于一个管理员只能为一个仓库的管理员，故（仓库，管理员，物品类型）都是关键字段，而数目为非关键字段。<br>这张表符合1NF元素不可分。符合2NF，因为证书数目由(仓库，物品类型)决定，但是(管理员，物品类型)也能决定。对于3NF，它也是符合的，因为只有一个非主属性，肯定是由码直接决定的啦。$\color{red}{那么BCNF的规范是什么呢？就是不能有主属性的互相推导。就是说，如果存在(仓库-&gt;管理员)(管理员-&gt;仓库)这种关系，是不符合BCNF的。}$<br>出现关键字段决定关键字段{(仓库-&gt;管理员)(管理员-&gt;仓库)}，将会有如下异常：</p><ol><li>删除异常：当仓库被清空后，所有”存储物品ID”和”数量”信息被删除的同时，”仓库ID”和”管理员ID”信息也被删除了。</li><li>插入异常：当仓库没有存储任何物品时，无法给仓库分配管理员。</li><li>更新异常：如果仓库换了管理员，则表中所有行的管理员ID都要修改。</li></ol><p>应该把仓库管理关系表分解为二个关系表：<br>表1<br>班级|    竞赛学科|    证书数目<br>:-:|:-:|:-:<br>1班    |物理    |10<br>1班    |化学    |15<br>2班    |生物|    20<br>2班|    物理|    10<br>… …|    … …|    … …</p><p>表2<br>班级|    班主任<br>:-:|:-:<br>1班|    刘老师<br>2班    |王老师<br>… …|    … …</p><h1 id="第四范式——属性之间不允许有非平凡且非函数依赖的多值依赖"><a href="#第四范式——属性之间不允许有非平凡且非函数依赖的多值依赖" class="headerlink" title="第四范式——属性之间不允许有非平凡且非函数依赖的多值依赖"></a>第四范式——属性之间不允许有非平凡且非函数依赖的多值依赖</h1><p>即当一个表中的非主属性互相独立时（3NF），这些非主属性不应该有多值。若有多值就违反了第四范式。<br>有这样一个用户联系方式表TELEPHONE(CUSTOMERID,PHONE,CELL)。CUSTOMERID为用户ID,PHONE为用户的固定电话,CELL为用户的移动电话。<br>本来，这是一个非常简单的第3范式表。主键为CUSTOMERID，不存在传递依赖。但在某些情况下，这样的表还是不合理的。比如说，用户有两个固定电话，两个移动电话。这时，表的具体表示如下：</p><table><thead><tr><th align="center">CUSTOMERID</th><th align="center">PHONE</th><th align="center">CELL</th></tr></thead><tbody><tr><td align="center">1000</td><td align="center">8828-1234</td><td align="center">149088888888</td></tr><tr><td align="center">1000</td><td align="center">8838-1234</td><td align="center">149099999999</td></tr></tbody></table><p>由于PHONE和CELL是互相独立的，而有些用户又有两个和多个值。这时此表就违反第四范式。<br>在这种情况下，此表的设计就会带来很多维护上的麻烦。例如，如果用户放弃第一行的固定电话和第二行的移动电话，那么这两行会合并吗？等等<br>解决问题的方法为，设计一个新表NEW_PHONE(CUSTOMERID,NUMBER,TYPE).这样就可以对每个用户处理不同类型的多个电话号码，而不会违反第四范式。<br>显然，第四范式的应用范围比较小，因为只有在某些特殊情况下，要考虑将表规范到第四范式。所以在实际应用中，一般不要求表满足第四范式。</p><h1 id="第五范式——最终范式，消除4NF中的连接依赖"><a href="#第五范式——最终范式，消除4NF中的连接依赖" class="headerlink" title="第五范式——最终范式，消除4NF中的连接依赖"></a>第五范式——最终范式，消除4NF中的连接依赖</h1><p>表必须可以分解为较小的表，除非那些表在逻辑上拥有与原始表相同的主键。<br>第五范式是在第四范式的基础上做的进一步规范化。第四范式处理的是相互独立的多值情况，而第五范式则处理相互依赖的多值情况。<br>有一个销售信息表SALES（SALEPERSON，VENDOR，PRODUCT）。SALEPERSON代表销售人员，VENDOR代表供货商，PRODUCT则代表产品。</p><p>在某些情况下，这个表中会产生一些冗余。可以将表分解为PERSON_VENDOR表（SALEPERSON，VENDOR）；PERSON_PRODUCT表（SALEPERSON，PRODUCT）；VENDOR­_PRODICT表（VENDOR，PRODUCT）</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>6种范式的关系为：$1NF\supset 2NF \supset 3NF \supset BCNF \supset 4NF \supset 5NF$<br>一般表达设计只考虑到BCNF即可，为了满足范式要求，需要把一张大表拆分开，到时候查询岂不是非常麻烦？是的，需要将这些表Join起来，如果数据量大的时候，连接非常耗时。$\color{red}{但有时为了加快数据的查询速度（减少多次查询）我们需要违反范式，做点数据冗余。}$</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.cnblogs.com/Diyo/p/11414424.html" target="_blank" rel="noopener">数据库6大范式</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么存在范式&quot;&gt;&lt;a href=&quot;#为什么存在范式&quot; class=&quot;headerlink&quot; title=&quot;为什么存在范式&quot;&gt;&lt;/a&gt;为什么存在范式&lt;/h1&gt;&lt;p&gt;引入范式的目的主要是解决数据冗余问题。&lt;br&gt;例如：&lt;br&gt;&lt;img alt=&quot;订单综述表&quot; dat
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://aemonswift.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="表设计" scheme="http://aemonswift.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%A1%A8%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="数据库" scheme="http://aemonswift.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="表设计" scheme="http://aemonswift.github.io/tags/%E8%A1%A8%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>mysql优化之使用规范</title>
    <link href="http://aemonswift.github.io/2019/11/03/mysql%E4%BC%98%E5%8C%96%E4%B9%8B%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/"/>
    <id>http://aemonswift.github.io/2019/11/03/mysql优化之使用规范/</id>
    <published>2019-11-03T13:05:23.000Z</published>
    <updated>2019-11-04T07:57:46.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础规范"><a href="#基础规范" class="headerlink" title="基础规范"></a>基础规范</h1><h2 id="1-使用InnoDB存储引擎"><a href="#1-使用InnoDB存储引擎" class="headerlink" title="1. 使用InnoDB存储引擎"></a>1. 使用InnoDB存储引擎</h2><p>支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高</p><h2 id="2-推荐使用utf8mb4字符集"><a href="#2-推荐使用utf8mb4字符集" class="headerlink" title="2. 推荐使用utf8mb4字符集"></a>2. 推荐使用utf8mb4字符集</h2><p>无需转码，无乱码风险, 支持emoji表情以及部分不常见汉字</p><h2 id="3-表、字段必须加注释"><a href="#3-表、字段必须加注释" class="headerlink" title="3. 表、字段必须加注释"></a>3. 表、字段必须加注释</h2><p> 方便他人理解字段意思，在后期维护中非常非常有用，不用去瞎猜这个字段是干嘛的。</p><h2 id="4-不在数据库做计算"><a href="#4-不在数据库做计算" class="headerlink" title="4. 不在数据库做计算"></a>4. 不在数据库做计算</h2><p>禁止使用存储过程、视图、触发器、Event。在并发量大的情况下，这些功能很可能将数据库拖跨，业务逻辑放到服务层具备更好的扩展性，能够轻易实现“增机器就加性能”。</p><h2 id="5-禁止存储文件"><a href="#5-禁止存储文件" class="headerlink" title="5. 禁止存储文件"></a>5. 禁止存储文件</h2><p>文件存储在文件系统，数据库里存URI</p><h2 id="6-控制单表数据量"><a href="#6-控制单表数据量" class="headerlink" title="6. 控制单表数据量"></a>6. 控制单表数据量</h2><p>单表记录控制在千万级，超过了可以进行分库分表</p><h2 id="7-不要在数据库中进行排序。"><a href="#7-不要在数据库中进行排序。" class="headerlink" title="7. 不要在数据库中进行排序。"></a>7. 不要在数据库中进行排序。</h2><p>特别是大数据量的排序，可考虑在程序中设计排序；</p><h2 id="8-不要对数据做真正意义的物理删除-DELETE…-。"><a href="#8-不要对数据做真正意义的物理删除-DELETE…-。" class="headerlink" title="8. 不要对数据做真正意义的物理删除(DELETE…)。"></a>8. 不要对数据做真正意义的物理删除(DELETE…)。</h2><p>可考虑逻辑删除，即在表中设计一个is_deleted字段标记该字段是否删除，防止毁灭性事件的发生；</p><h2 id="9-避免在数据库中做计算，减轻数据库压力"><a href="#9-避免在数据库中做计算，减轻数据库压力" class="headerlink" title="9. 避免在数据库中做计算，减轻数据库压力"></a>9. 避免在数据库中做计算，减轻数据库压力</h2><h2 id="10-避免JOIN查询，请尽可能的使用单表查询，减少查询复杂度，减轻数据库压力"><a href="#10-避免JOIN查询，请尽可能的使用单表查询，减少查询复杂度，减轻数据库压力" class="headerlink" title="10. 避免JOIN查询，请尽可能的使用单表查询，减少查询复杂度，减轻数据库压力"></a>10. 避免JOIN查询，请尽可能的使用单表查询，减少查询复杂度，减轻数据库压力</h2><h2 id="11-禁止在数据库中使用视图、存储过程、函数、触发器、事件"><a href="#11-禁止在数据库中使用视图、存储过程、函数、触发器、事件" class="headerlink" title="11. 禁止在数据库中使用视图、存储过程、函数、触发器、事件"></a>11. 禁止在数据库中使用视图、存储过程、函数、触发器、事件</h2><h1 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h1><h2 id="1-库名、表名、字段名、索引名：小写，下划线风格"><a href="#1-库名、表名、字段名、索引名：小写，下划线风格" class="headerlink" title="1. 库名、表名、字段名、索引名：小写，下划线风格"></a>1. 库名、表名、字段名、索引名：小写，下划线风格</h2><p>非唯一索引按照”ix字段名称[字段名称]”进行命名，如ix_uid_name;<br>唯一索引按照”uk字段名称[字段名称]”进行命名，如uk_uid_name;</p><h2 id="2-表必须有主键，例如自增主键"><a href="#2-表必须有主键，例如自增主键" class="headerlink" title="2. 表必须有主键，例如自增主键"></a>2. 表必须有主键，例如自增主键</h2><p>a. 主键递增，数据行写入可以提高插入性能;<br>b. 主键要选择较短的数据类型，Innodb引擎普通索引都会保存主键的值，较短的数据类型可以有效的减少索引的磁盘空间，提高索引的缓存效率;<br>c. 保证实体的完整性，唯一性。</p><h2 id="3-不要使用外键。"><a href="#3-不要使用外键。" class="headerlink" title="3. 不要使用外键。"></a>3. 不要使用外键。</h2><p>如果有外键约束，用应用程序控制。外键会导致表与表之间耦合，update与delete操作都会涉及相关联的表，十分影响sql 的性能，甚至会造成死锁。高并发情况下容易造成数据库性能下降，大数据高并发业务场景数据库使用以性能优先。</p><h1 id="字段设计规范"><a href="#字段设计规范" class="headerlink" title="字段设计规范"></a>字段设计规范</h1><h2 id="1-把字段定义为NOT-NULL并且提供默认值。"><a href="#1-把字段定义为NOT-NULL并且提供默认值。" class="headerlink" title="1. 把字段定义为NOT NULL并且提供默认值。"></a>1. 把字段定义为NOT NULL并且提供默认值。</h2><ul><li>数值类型使用：NOT NULL DEFAULT 0</li><li>字符类型使用：NOT NULL DEFAULT “”</li><li>$\color{red}{timestamp类型不指定默认值的话，MariaDB 会默认给0；多于一个timestamp字段没有指定默认值，会自动给一个timestamp默认值为 CURRENT_TIMESTAMP ON UPDATE CURRENT\_TIMESTAMP，其他为0。}$</li></ul><p>主要原因在于：</p><p>a. null的列使索引/索引统计/值比较都更加复杂，对MySQL来说更难优化;<br>b. null 这种类型MySQL内部需要进行特殊处理，增加数据库处理记录的复杂性；同等条件下，表中有较多空字段的时候，数据库的处理性能会降低很多;<br>c. null值需要更多的存储空间，无论是表还是索引中每行中的null的列都需要额外的空间来标识;<br>d. 对null 的处理时候，只能采用is null或is not null，而不能采用=、in、&lt;、&lt;&gt;、!=、not in这些操作符号。如：where name!=’zhangsan’，如果存在name为null值的记录，查询结果就不会包含name为null值的记录。</p><h2 id="2-不要使用TEXT、BLOB类型"><a href="#2-不要使用TEXT、BLOB类型" class="headerlink" title="2. 不要使用TEXT、BLOB类型"></a>2. 不要使用TEXT、BLOB类型</h2><p>会浪费更多的磁盘和内存空间，非必要的大量的大字段查询会淘汰掉热数据，导致内存命中率急剧降低，影响数据库性能,如果必须要使用则独立出来一张表，用主键来对应，避免影响其它字段索引效率。</p><h2 id="3-避免使用浮点数类型"><a href="#3-避免使用浮点数类型" class="headerlink" title="3. 避免使用浮点数类型"></a>3. 避免使用浮点数类型</h2><p>计算机处理整型比浮点型快N倍，如果必须使用，请将浮点型扩大N倍后转为整型；建议使用整数，小数容易导致钱对不上。即通常做法为：涉及精确金额相关用途的字段类型，强烈建议扩大N倍后转换成整型存储（例如金额中的分扩大百倍后存储成整型），避免浮点数加减出现不准确的问题，也强烈建议比实际需求多保留一位，便于后续财务方面对账更加准确</p><h2 id="4-必须使用varchar存储手机号"><a href="#4-必须使用varchar存储手机号" class="headerlink" title="4. 必须使用varchar存储手机号"></a>4. 必须使用varchar存储手机号</h2><p>手机号会去做数学运算么？</p><h2 id="5-为提高效率可以牺牲范式设计，冗余数据"><a href="#5-为提高效率可以牺牲范式设计，冗余数据" class="headerlink" title="5. 为提高效率可以牺牲范式设计，冗余数据"></a>5. 为提高效率可以牺牲范式设计，冗余数据</h2><p>冗余字段选择要求：<br>a. 不是频繁修改的字段;<br>b. 不是 varchar 超长字段，更不能是 text 字段。</p><h2 id="6-所有表都必须要有主键"><a href="#6-所有表都必须要有主键" class="headerlink" title="6. 所有表都必须要有主键"></a>6. 所有表都必须要有主键</h2><p>主键类型必须为：INT/BIGINT  unsigned NOT NULL AUTO_INCREMENT，提高顺序insert效率，强烈建议该列与业务没有联系，并且不建议使用组合主键，仅仅作为自增主键id使用。<br>INT／BIGINT如何选择？<br>a. 当表的预估数据量在42亿条以内，请使用INT UNSIGNED；b. 当表的预估数据量超过42亿条，请使用BIGINT UNSIGNED;<br>为什么选择自增id作为主键？<br>a. 主键自增，数据行写入可以提高插入性能，可以避免page分裂，减少表碎片提升空间和内存的使用<br>b. 自增型主键设计(int,bigint)可以降低二级索引的空间，提升二级索引的内存命中率；<br>c. 主键要选择较短的数据类型， Innodb引擎普通索引都会保存主键的值，较短的数据类型可以有效的减少索引的磁盘空间，提高索引的缓存效率;<br>d. 无主键的表删除，在row模式的主从架构，会导致备库夯住。</p><h2 id="7-所有表必须携带ctime-创建时间-mtime-最后修改时间-这两个字段，便于数据分析以及故障排查；"><a href="#7-所有表必须携带ctime-创建时间-mtime-最后修改时间-这两个字段，便于数据分析以及故障排查；" class="headerlink" title="7. 所有表必须携带ctime(创建时间),mtime(最后修改时间)这两个字段，便于数据分析以及故障排查；"></a>7. 所有表必须携带ctime(创建时间),mtime(最后修改时间)这两个字段，便于数据分析以及故障排查；</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#两个字段的类型如下，只需要在建表时建立即可，不需要开发人员再往其中插入时间值，前提是INSERT INTO语句显示的字段名称：</span></span><br><span class="line">ctime TIMESATMP NOT NULL DEFAULT CURRENT_TIMESTAMP <span class="keyword">COMMENT</span> ‘创建时间’;</span><br><span class="line">mtime TIMESATMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> ‘最后修改时间’</span><br></pre></td></tr></table></figure><h2 id="9-对于CHAR-N-VARCHAR-N-类型，在满足够用的前提下，尽可能小的选择N的大小，并且建议N-lt-255，用于节省磁盘空间和内存空间；"><a href="#9-对于CHAR-N-VARCHAR-N-类型，在满足够用的前提下，尽可能小的选择N的大小，并且建议N-lt-255，用于节省磁盘空间和内存空间；" class="headerlink" title="9. 对于CHAR(N)/VARCHAR(N)类型，在满足够用的前提下，尽可能小的选择N的大小，并且建议N&lt;255，用于节省磁盘空间和内存空间；"></a>9. 对于CHAR(N)/VARCHAR(N)类型，在满足够用的前提下，尽可能小的选择N的大小，并且建议N&lt;255，用于节省磁盘空间和内存空间；</h2><h2 id="10-使用TINYINT代替ENUM类型，新增ENUM类型需要在DDL操作，对于TINYINT类型在数据库字段COMMENT和程序代码中做好备注信息，避免混淆"><a href="#10-使用TINYINT代替ENUM类型，新增ENUM类型需要在DDL操作，对于TINYINT类型在数据库字段COMMENT和程序代码中做好备注信息，避免混淆" class="headerlink" title="10. 使用TINYINT代替ENUM类型，新增ENUM类型需要在DDL操作，对于TINYINT类型在数据库字段COMMENT和程序代码中做好备注信息，避免混淆"></a>10. 使用TINYINT代替ENUM类型，新增ENUM类型需要在DDL操作，对于TINYINT类型在数据库字段COMMENT和程序代码中做好备注信息，避免混淆</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num enum('0','1','2','3') <span class="keyword">comment</span> <span class="string">'enum枚举类型'</span> );</span><br><span class="line">`num` tinyint(4) NOT NULL DEFAULT '0' <span class="keyword">COMMENT</span> <span class="string">'TINY枚举类型：0-不通过，1-通过'</span></span><br></pre></td></tr></table></figure><h2 id="10-JOIN查询时，用于JOIN的字段定义必须完全相同-避免隐式转换-，并且建立索引。"><a href="#10-JOIN查询时，用于JOIN的字段定义必须完全相同-避免隐式转换-，并且建立索引。" class="headerlink" title="10. JOIN查询时，用于JOIN的字段定义必须完全相同(避免隐式转换)，并且建立索引。"></a>10. JOIN查询时，用于JOIN的字段定义必须完全相同(避免隐式转换)，并且建立索引。</h2><h2 id="11-存储单个IP时，必须使用整型INT-UNSIGNED类型，不允许使用字符型VARCHAR-存储单个IP。"><a href="#11-存储单个IP时，必须使用整型INT-UNSIGNED类型，不允许使用字符型VARCHAR-存储单个IP。" class="headerlink" title="11. 存储单个IP时，必须使用整型INT UNSIGNED类型，不允许使用字符型VARCHAR()存储单个IP。"></a>11. 存储单个IP时，必须使用整型INT UNSIGNED类型，不允许使用字符型VARCHAR()存储单个IP。</h2><h2 id="时间类型，首选使用整型INT、INT-UNSIGNED类型，其次使用timestamp类型。"><a href="#时间类型，首选使用整型INT、INT-UNSIGNED类型，其次使用timestamp类型。" class="headerlink" title="时间类型，首选使用整型INT、INT UNSIGNED类型，其次使用timestamp类型。"></a>时间类型，首选使用整型INT、INT UNSIGNED类型，其次使用timestamp类型。</h2><ul><li>INT: 存储范围：-2147483648 to 2147483647 对应的时间范围: 1970/1/1 8:00:00 – 2038/1/19 11:14:07</li><li>INT UNSIGNED: 存储范围：0 to 4294967295 对应的时间范围：1970/1/1 8:00:00 – 2106/2/7 14:28:15<h2 id="12-日期类型，请使用date类型。"><a href="#12-日期类型，请使用date类型。" class="headerlink" title="12. 日期类型，请使用date类型。"></a>12. 日期类型，请使用date类型。</h2></li></ul><h1 id="索引设计规范"><a href="#索引设计规范" class="headerlink" title="索引设计规范"></a>索引设计规范</h1><h2 id="1-禁止在更新十分频繁、区分度不高的属性上建立索引"><a href="#1-禁止在更新十分频繁、区分度不高的属性上建立索引" class="headerlink" title="1. 禁止在更新十分频繁、区分度不高的属性上建立索引"></a>1. 禁止在更新十分频繁、区分度不高的属性上建立索引</h2><p>a. 更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能;<br>b. “性别”这种区分度不大的属性，建立索引是没有什么意义的，故找区分度大的字段作为索引。</p><h2 id="2-建立组合索引，必须把区分度高的字段放在最左边"><a href="#2-建立组合索引，必须把区分度高的字段放在最左边" class="headerlink" title="2. 建立组合索引，必须把区分度高的字段放在最左边"></a>2. 建立组合索引，必须把区分度高的字段放在最左边</h2><p>因为使用单字段查询时会使用组合索引的左边字段而不使用右边的字段，如果 where a=? and b=? ， a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即可。</p><h2 id="3-页面搜索严禁左模糊或者全模糊"><a href="#3-页面搜索严禁左模糊或者全模糊" class="headerlink" title="3. 页面搜索严禁左模糊或者全模糊"></a>3. 页面搜索严禁左模糊或者全模糊</h2><p>索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引, 如果需要请走搜索引擎来解决。</p><h1 id="SQL使用规范"><a href="#SQL使用规范" class="headerlink" title="SQL使用规范"></a>SQL使用规范</h1><h2 id="1-禁止使用SELECT-，只获取必要的字段，需要显示说明列属性"><a href="#1-禁止使用SELECT-，只获取必要的字段，需要显示说明列属性" class="headerlink" title="1. 禁止使用SELECT *，只获取必要的字段，需要显示说明列属性"></a>1. 禁止使用SELECT *，只获取必要的字段，需要显示说明列属性</h2><p>a. 消耗cpu，io，内存，带宽;<br>b. 不能有效的利用覆盖索引;<br>c. 使用SELECT *容易在增加或者删除字段后出现程序BUG, 不具有扩展性。<br>d. 没有避免新增字段对程序应用逻辑的影响</p><h2 id="2-使用INSERT-INTO-t-xxx-VALUES-xxx-，必须显示指定插入的列属性"><a href="#2-使用INSERT-INTO-t-xxx-VALUES-xxx-，必须显示指定插入的列属性" class="headerlink" title="2. 使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性"></a>2. 使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性</h2><p>容易在增加或者删除字段后出现程序BUG</p><h2 id="3-务必请使用“同类型”进行比较，否则可能全表扫面"><a href="#3-务必请使用“同类型”进行比较，否则可能全表扫面" class="headerlink" title="3. 务必请使用“同类型”进行比较，否则可能全表扫面"></a>3. 务必请使用“同类型”进行比较，否则可能全表扫面</h2><p>SELECT name FROM t_user WHERE phone=1888888888 会导致全表扫描.</p><h2 id="4-禁止在WHERE条件的上使用函数或者计算"><a href="#4-禁止在WHERE条件的上使用函数或者计算" class="headerlink" title="4. 禁止在WHERE条件的上使用函数或者计算"></a>4. 禁止在WHERE条件的上使用函数或者计算</h2><p>解读：SELECT naem FROM tuser WHERE date(createdatatime)=’2017-12-29’ 会导致全表扫描<br>推荐的写法是：SELECT name FROM tuser WHERE createdatatime&gt;= ‘2017-12-29’ and create_datatime &lt; ‘2017-12-30’</p><h2 id="5-禁止负向查询，以及-开头的模糊查询"><a href="#5-禁止负向查询，以及-开头的模糊查询" class="headerlink" title="5. 禁止负向查询，以及%开头的模糊查询"></a>5. 禁止负向查询，以及%开头的模糊查询</h2><p>a. 负向查询条件：NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT IN、NOT LIKE等，会导致全表扫描。b. %开头的模糊查询，会导致全表扫描。</p><h2 id="6-不要大表使用JOIN查询，禁止大表使用子查询"><a href="#6-不要大表使用JOIN查询，禁止大表使用子查询" class="headerlink" title="6. 不要大表使用JOIN查询，禁止大表使用子查询"></a>6. 不要大表使用JOIN查询，禁止大表使用子查询</h2><p>会产生临时表，消耗较多内存与CPU，极大影响数据库性能。</p><h2 id="7-OR改写为IN-或者UNION"><a href="#7-OR改写为IN-或者UNION" class="headerlink" title="7. OR改写为IN()或者UNION"></a>7. OR改写为IN()或者UNION</h2><p>原因很简单or不会走索引。</p><h2 id="8-简单的事务"><a href="#8-简单的事务" class="headerlink" title="8. 简单的事务"></a>8. 简单的事务</h2><p>事务就像程序中的锁一样粒度尽可能要小。</p><h2 id="9-不要一次更新大量数据"><a href="#9-不要一次更新大量数据" class="headerlink" title="9. 不要一次更新大量数据"></a>9. 不要一次更新大量数据</h2><p>数据更新会对行或者表加锁，应该分为多次更新。</p><h2 id="10-生产环境中，表一旦设计好，字段只允许增加-ADD-COLUMN-，禁止减少-DROP-COLUMN-，禁止改名称-CHANGE-MODIFY-COLUMN"><a href="#10-生产环境中，表一旦设计好，字段只允许增加-ADD-COLUMN-，禁止减少-DROP-COLUMN-，禁止改名称-CHANGE-MODIFY-COLUMN" class="headerlink" title="10. 生产环境中，表一旦设计好，字段只允许增加(ADD COLUMN)，禁止减少(DROP COLUMN)，禁止改名称(CHANGE/MODIFY COLUMN);"></a>10. 生产环境中，表一旦设计好，字段只允许增加(ADD COLUMN)，禁止减少(DROP COLUMN)，禁止改名称(CHANGE/MODIFY COLUMN);</h2><h2 id="11-禁止使用UPDATE-…-LIMIT-…和DELETE-…-LIMIT-…操作"><a href="#11-禁止使用UPDATE-…-LIMIT-…和DELETE-…-LIMIT-…操作" class="headerlink" title="11. 禁止使用UPDATE … LIMIT …和DELETE … LIMIT …操作"></a>11. 禁止使用UPDATE … LIMIT …和DELETE … LIMIT …操作</h2><p>因为你无法得知自己究竟更新或者删除了哪些数据，请务必添加ORDER BY进行排序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是错误的语法示例</span></span><br><span class="line"><span class="keyword">UPDATE</span> tb <span class="keyword">SET</span> col1=value1 <span class="keyword">LIMIT</span> n;</span><br><span class="line"><span class="comment"># 这是错误的语法示例</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tb <span class="keyword">LIMIT</span> n;</span><br><span class="line"><span class="comment"># 这是正确的语法示例</span></span><br><span class="line"><span class="keyword">UPDATE</span> tb <span class="keyword">SET</span> col1=value1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span> <span class="keyword">LIMIT</span> n;</span><br><span class="line"><span class="comment"># 这是正确的语法示例</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tb <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span> <span class="keyword">LIMIT</span> n;</span><br></pre></td></tr></table></figure><h2 id="12-禁止超过2张表的JOIN查询"><a href="#12-禁止超过2张表的JOIN查询" class="headerlink" title="12. 禁止超过2张表的JOIN查询"></a>12. 禁止超过2张表的JOIN查询</h2><h2 id="13-禁止使用子查询"><a href="#13-禁止使用子查询" class="headerlink" title="13. 禁止使用子查询"></a>13. 禁止使用子查询</h2><h2 id="14-禁止出现冗余索引，如索引-a-索引-a-b-，此时索引-a-为冗余索引"><a href="#14-禁止出现冗余索引，如索引-a-索引-a-b-，此时索引-a-为冗余索引" class="headerlink" title="14. 禁止出现冗余索引，如索引(a),索引(a,b)，此时索引(a)为冗余索引;"></a>14. 禁止出现冗余索引，如索引(a),索引(a,b)，此时索引(a)为冗余索引;</h2><h2 id="15-禁止使用ORDER-BY-RAND-排序，性能极其低下。"><a href="#15-禁止使用ORDER-BY-RAND-排序，性能极其低下。" class="headerlink" title="15. 禁止使用ORDER BY RAND()排序，性能极其低下。"></a>15. 禁止使用ORDER BY RAND()排序，性能极其低下。</h2><h2 id="16-禁止使用外键，外键的逻辑应当由程序去控制"><a href="#16-禁止使用外键，外键的逻辑应当由程序去控制" class="headerlink" title="16. 禁止使用外键，外键的逻辑应当由程序去控制"></a>16. 禁止使用外键，外键的逻辑应当由程序去控制</h2><p>外键会导致表与表之间耦合，UPDATE与DELETE操作都会涉及相关联的表，十分影响SQL 的性能，甚至会造成死锁。高并发情况下容易造成数据库性能，大数据高并发业务场景数据库使用以性能优先。</p><h2 id="17-禁止回退表的DDL操作"><a href="#17-禁止回退表的DDL操作" class="headerlink" title="17. 禁止回退表的DDL操作"></a>17. 禁止回退表的DDL操作</h2><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="1-创建表"><a href="#1-创建表" class="headerlink" title="1. 创建表"></a>1. 创建表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是正确的语法示范</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`test`</span> (</span><br><span class="line">  <span class="string">`c1`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'自增主键ID'</span>,</span><br><span class="line">  <span class="string">`c2`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'无符号数值型字段'</span>,</span><br><span class="line">  <span class="string">`c3`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'有符号数值型字段'</span>,</span><br><span class="line">  <span class="string">`c4`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'变长字符型字段'</span>,</span><br><span class="line">  <span class="string">`ctime`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间类型字段'</span>,</span><br><span class="line">  <span class="string">`mtime`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'更新时间类型字段'</span>,</span><br><span class="line">  <span class="string">`c7`</span> <span class="built_in">tinyint</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'枚举类型字段：0-xxx,1-xxx,2-xxx'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`c1`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uk_c2`</span> (<span class="string">`c2`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`ix_c3`</span> (<span class="string">`c3`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'测试表'</span></span><br></pre></td></tr></table></figure><h2 id="更改表"><a href="#更改表" class="headerlink" title="更改表"></a>更改表</h2><h3 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a>添加字段</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是正确的语法示范</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">test</span> <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> c8 <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'添加字段测试'</span>;</span><br></pre></td></tr></table></figure><p>添加字段时禁止使用after/before属性，避免数据偏移。</p><h3 id="变更字段"><a href="#变更字段" class="headerlink" title="变更字段"></a>变更字段</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是正确的语法示范</span></span><br><span class="line"><span class="comment"># MODIFY只修改字段定义（优先使用）</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">test</span> <span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> c8 <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'MODIFY修改字段定义'</span>;</span><br><span class="line"><span class="comment"># CHANGE修改字段名称</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">test</span> <span class="keyword">CHANGE</span> <span class="keyword">COLUMN</span> c7 c8 <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'CHANGE修改字段名称'</span>;</span><br></pre></td></tr></table></figure><h3 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是正确的语法示范</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">test</span> <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> c8;</span><br></pre></td></tr></table></figure><h3 id="添加主键"><a href="#添加主键" class="headerlink" title="添加主键"></a>添加主键</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是正确的语法示范</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span>  <span class="keyword">test</span> <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span>(c1);</span><br></pre></td></tr></table></figure><h3 id="删除主键"><a href="#删除主键" class="headerlink" title="删除主键"></a>删除主键</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是正确的语法示范</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">test</span> <span class="keyword">DROP</span> PRIMARY <span class="keyword">KEY</span>;</span><br></pre></td></tr></table></figure><h3 id="添加普通索引"><a href="#添加普通索引" class="headerlink" title="添加普通索引"></a>添加普通索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是正确的语法示范</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">test</span> <span class="keyword">add</span> <span class="keyword">INDEX</span> ix_c3(c3);</span><br></pre></td></tr></table></figure><p>如果创建的是联合索引，筛选度高的列靠左</p><h3 id="添加唯一索引"><a href="#添加唯一索引" class="headerlink" title="添加唯一索引"></a>添加唯一索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是正确的语法示范</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">test</span> <span class="keyword">add</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> uk_c2(c2);</span><br></pre></td></tr></table></figure><h3 id="删除普通索引"><a href="#删除普通索引" class="headerlink" title="删除普通索引"></a>删除普通索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是正确的语法示范</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">test</span> <span class="keyword">DROP</span> <span class="keyword">INDEX</span> ix_c3;</span><br></pre></td></tr></table></figure><h3 id="删除唯一索引"><a href="#删除唯一索引" class="headerlink" title="删除唯一索引"></a>删除唯一索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是正确的语法示范</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">test</span> <span class="keyword">DROP</span> <span class="keyword">INDEX</span> uk_c2;</span><br></pre></td></tr></table></figure><p>同一张表的修改语句请合并，避免多次重建表影响读写</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">test</span> <span class="keyword">add</span> col1 <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'col1字段用途'</span>,<span class="keyword">add</span> <span class="keyword">index</span> idx_col2(col2),<span class="keyword">modify</span> col3 <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'col3字段用途'</span></span><br></pre></td></tr></table></figure><h2 id="插入语句"><a href="#插入语句" class="headerlink" title="插入语句"></a>插入语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># INSERT INTO语句的正确语法示例</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb(col1,col2) <span class="keyword">VALUES</span>(value1,values2);</span><br></pre></td></tr></table></figure><p>INSERT INTO语句需要显示指明字段名称;<br>对于多次单条INSERT INTO语句，务必使用批量INSERT INTO语句，提高INSERT INTO语句效率，如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多次单条INSERT INTO，这是错误的语法示例</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span>(col1,col2) <span class="keyword">VALUES</span>(value1,values2);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span>(col1,col2) <span class="keyword">VALUES</span>(value3,values4);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span>(col1,col2) <span class="keyword">VALUES</span>(value5,values6);</span><br><span class="line"><span class="comment"># 批量INSERT INTO语句，这是正确的语法示例</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span>(col1,col2) <span class="keyword">VALUES</span>(value1,values2),(value3,values4),(value5,values6);</span><br></pre></td></tr></table></figure><h2 id="更新语句"><a href="#更新语句" class="headerlink" title="更新语句"></a>更新语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># UPDATE语句的正确语法示例</span></span><br><span class="line"><span class="keyword">UPDATE</span> tb <span class="keyword">SET</span> col1=value1,col2=value2,col3=value3 <span class="keyword">WHERE</span> col0=value0 <span class="keyword">AND</span> col5=value5;</span><br></pre></td></tr></table></figure><p>SET后接的并列字段分隔符为”逗号(,)”，而不是常见的”AND”，使用”AND”也能将UPDATE语句执行成功，但意义完全不一样。原来在UPDATE … SET后接分隔符为”AND”的语句，由于AND的优先级较高，所以先处理“AND”，再处理“＝”，于是“＝”后面的值只有逻辑运算的结果true(1) / false(0)。例如：update t set c1=11 and c2=’AA’ where id=1; 在这条语句中MySQL将c1=11 and c2=’AA’解析成了c1=(11 and c2=’AA’)<br>强烈建议UPDATE语句后携带WHERE条件，防止灾难性事件的发生；<br>使用UPDATE修改大量数据时，该语句极易引起主从复制延迟；<br>禁止使用UPDATE … LIMIT …语法</p><h2 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是错误的语法示范</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tb <span class="keyword">WHERE</span> col1=value1;</span><br><span class="line"><span class="comment"># 这是正确的语法示范</span></span><br><span class="line"><span class="keyword">SELECT</span> col1,col2 <span class="keyword">FROM</span> tb <span class="keyword">WHERE</span> col1=value1;</span><br></pre></td></tr></table></figure><p>禁止使用SELECT * FROM语句，SELECT只获取需要的字段，既防止了新增字段对程序应用逻辑的影响，又减少了对程序和数据库的性能影响；<br>合理的使用数据类型，避免出现隐式转换，隐式转换无法使用索引且效率低，如：SELECT name FROM tb WHERE id=’1’; 此时id为int类型，此时出现隐式转换以及全表扫描。<br>不建议使用％前缀模糊查询，导致查询无法使用索引，如：SELECT id FROM tb WHERE name LIKE ‘%test’;<br>对于LIMIT操作，强烈建议使先ORDER BY 再LIMIT，即ORDER BY c1 LIMIT n；</p><h2 id="删除语句"><a href="#删除语句" class="headerlink" title="删除语句"></a>删除语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DELETE语句的正确语法示例</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tb <span class="keyword">WHERE</span> col0=value0 <span class="keyword">AND</span> col1=value1;</span><br></pre></td></tr></table></figure><p>强烈建议DELETE语句后携带WHERE条件，防止灾难性事件的发生；<br>使用DELETE修改大量数据时，该语句极易引起主从复制延迟；<br>禁止使用DELETE … LIMIT …语法</p><h2 id="其它书写规范"><a href="#其它书写规范" class="headerlink" title="其它书写规范"></a>其它书写规范</h2><ol><li>禁止再where后面给字段使用mysql中的函数<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是错误的语法示范</span></span><br><span class="line"><span class="keyword">SELECT</span> col1,col2 <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">WHERE</span> <span class="keyword">unix_timestamp</span>(col1)=value1;</span><br><span class="line"><span class="comment"># 这是正确的语法示范</span></span><br><span class="line"><span class="keyword">SELECT</span> col1,col2 <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">WHERE</span> col1=<span class="keyword">unix_timestamp</span>(value1);</span><br></pre></td></tr></table></figure></li></ol><h2 id="强烈建议字段放在操作符左边"><a href="#强烈建议字段放在操作符左边" class="headerlink" title="强烈建议字段放在操作符左边"></a>强烈建议字段放在操作符左边</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是错误的语法示范</span></span><br><span class="line"><span class="keyword">SELECT</span> col1,col2 <span class="keyword">FROM</span> tb <span class="keyword">WHERE</span> value1=col1l</span><br><span class="line"><span class="comment"># 这是正确的语法示范</span></span><br><span class="line"><span class="keyword">SELECT</span> col1,col2 <span class="keyword">FROM</span> tb <span class="keyword">WHERE</span> col1=value1;</span><br></pre></td></tr></table></figure><h2 id="禁止将字符类型传入到整型类型字段中，也禁止整形类型传入到字段类型中，存在隐式转换的问题；"><a href="#禁止将字符类型传入到整型类型字段中，也禁止整形类型传入到字段类型中，存在隐式转换的问题；" class="headerlink" title="禁止将字符类型传入到整型类型字段中，也禁止整形类型传入到字段类型中，存在隐式转换的问题；"></a>禁止将字符类型传入到整型类型字段中，也禁止整形类型传入到字段类型中，存在隐式转换的问题；</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是错误的语法示范</span></span><br><span class="line"><span class="comment"># var_col字段为VARCHAR类型</span></span><br><span class="line"><span class="keyword">SELECT</span> col1,col2 <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">WHERE</span> var_col=<span class="number">123</span>;</span><br><span class="line"><span class="comment"># int_col字段为INT类型</span></span><br><span class="line"><span class="keyword">SELECT</span> col1,col2 <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">WHERE</span> int_col=<span class="string">'123'</span>;</span><br><span class="line"><span class="comment"># 这是正确的语法示范</span></span><br><span class="line"><span class="comment"># var_col字段为VARCHAR类型</span></span><br><span class="line"><span class="keyword">SELECT</span> col1,col2 <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">WHERE</span> var_col=<span class="string">'123'</span>;</span><br><span class="line"><span class="comment"># int_col字段为INT类型</span></span><br><span class="line"><span class="keyword">SELECT</span> col1,col2 <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">WHERE</span> int_col=<span class="number">123</span>;</span><br></pre></td></tr></table></figure><h1 id="数据库配置规范"><a href="#数据库配置规范" class="headerlink" title="数据库配置规范"></a>数据库配置规范</h1><p>如果应用使用的是长连接，应用必须具有自动重连的机制，但请避免每执行一个SQL去检查一次DB可用性；<br>如果应用使用的是长连接，应用应该具有连接的TIMEOUT检查机制，及时回收长时间没有使用的连接，TIMEOUT时间一般建议为2小时；<br>程序访问数据库连接的字符集请设置为utf8mb4；<br>程序中禁止一切DDL操作。<br>禁止使用应用程序配置文件内的帐号手工访问线上数据库，大部分配置文件内的数据库配置的是主库，你无法预知你的一条SQL会不会导致MySQL崩溃；<br>突发性大量操作数据库等操作时，需进行流量评估，避免数据库出现瓶颈；<br>批量清洗数据，应避开业务高峰期时段执行，并在执行过程中观察服务状态；<br>禁止在主库上执行后台管理和统计类的功能查询，这种复杂类的SQL会造成CPU的升高，进而会影响业务。</p><h1 id="常用字段数据类型范围"><a href="#常用字段数据类型范围" class="headerlink" title="常用字段数据类型范围"></a>常用字段数据类型范围</h1><table><thead><tr><th align="center">数值</th><th align="center">取值范围</th></tr></thead><tbody><tr><td align="center">TINYINT(4)</td><td align="center">-128 ~ 127</td></tr><tr><td align="center">TINYINT(4) UNSIGNED</td><td align="center">0 ~ 255</td></tr><tr><td align="center">SMALLINT(6)</td><td align="center">-32768 ~ 32767</td></tr><tr><td align="center">SMALLINT(6) UNSIGNED</td><td align="center">0 ~ 65535</td></tr><tr><td align="center">MEDIUMINT(8)</td><td align="center">-8388608 ~ 8388607</td></tr><tr><td align="center">MEDIUMINT(8) UNSIGNED</td><td align="center">0 ~ 16777215</td></tr><tr><td align="center">INT(11)</td><td align="center">-2147483648 ~ 2147483647</td></tr><tr><td align="center">INT(11) UNSIGNED</td><td align="center">0 ~ 4294967295</td></tr><tr><td align="center">BIGINT(20)</td><td align="center">-9223372036854775808 ~ 9223372036854775807</td></tr><tr><td align="center">BIGINT(20) UNSIGNED</td><td align="center">0 ~ 18446744073709551615</td></tr></tbody></table><p>VARCHAR(N)：在MySQL数据库中，VARCHAR(N)中的N代表N个字符，不管你是中文字符还是英文字符，VARCHAR(N)能存储最大为N个中文字符/英文字符。<br>TIMESTAMP: 1970-01-01 00:00:01 UTC ~2038-01-19 03:14:07 UTC<br>DATETIME: 1000-01-0100:00:00 ~ 9999-12-31 23:59:59</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://imysql.com/2014/09/14/mysql-faq-why-innodb-table-using-autoinc-int-as-pk.shtml" target="_blank" rel="noopener">为什么InnoDB表要建议用自增列做主键</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基础规范&quot;&gt;&lt;a href=&quot;#基础规范&quot; class=&quot;headerlink&quot; title=&quot;基础规范&quot;&gt;&lt;/a&gt;基础规范&lt;/h1&gt;&lt;h2 id=&quot;1-使用InnoDB存储引擎&quot;&gt;&lt;a href=&quot;#1-使用InnoDB存储引擎&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://aemonswift.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://aemonswift.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>mysql关键字执行顺序</title>
    <link href="http://aemonswift.github.io/2019/11/03/mysql%E5%85%B3%E9%94%AE%E5%AD%97%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <id>http://aemonswift.github.io/2019/11/03/mysql关键字执行顺序/</id>
    <published>2019-11-03T12:32:30.000Z</published>
    <updated>2019-11-04T07:47:58.126Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL关键字执行顺序"><a href="#SQL关键字执行顺序" class="headerlink" title="SQL关键字执行顺序"></a>SQL关键字执行顺序</h1><ol><li>from</li><li>join</li><li>on </li><li>where </li><li>group by(开始使用select中的别名，后面的语句中都可以使用)</li><li>avr,sum…等函数</li><li>having </li><li>select </li><li>distinct</li><li>order by </li><li>limit </li></ol><p>所有的 查询语句都是从from开始执行的，在执行过程中，每个步骤都会为下一个步骤生成一个虚拟表，这个虚拟表将作为下一个执行步骤的输入。 </p><ol><li>首先对from子句中的前两个表执行一个笛卡尔乘积，此时生成虚拟表 vt1（选择相对小的表做基础表）</li><li>接下来便是应用on筛选器，on 中的逻辑表达式将应用到 vt1 中的各个行，筛选出满足on逻辑表达式的行，生成虚拟表 vt2 </li><li>如果是outer join 那么这一步就将添加外部行，left outer jion 就把左表在第二步中过滤的添加进来，如果是right outer join 那么就将右表在第二步中过滤掉的行添加进来，这样生成虚拟表 vt3 </li><li>如果 from 子句中的表数目多余两个表，那么就将vt3和第三个表连接从而计算笛卡尔乘积，生成虚拟表，该过程就是一个重复1-3的步骤，最终得到一个新的虚拟表 vt3。 </li><li>用where筛选器，对上一步生产的虚拟表引用where筛选器，生成虚拟表vt4。这里存在一个问题。$\color{red}{对于包含outer join子句的查询，就有一个让人感到困惑的问题，到底在on筛选器还是用where筛选器指定逻辑表达式呢？on和where的最大区别在于，如果在on应用逻辑表达式那么在第三步outer join中还可以把移除的行再次添加回来，而where的移除的最终的。}$例如：有一个学生表（班级,姓名）和一个成绩表(姓名,成绩)，我现在需要返回一个x班级的全体同学的成绩，但是这个班级有几个学生缺考，也就是说在成绩表中没有记录。为了得到我们预期的结果我们就需要在on子句指定学生和成绩表的关系（学生.姓名=成绩.姓名）那么我们是否发现在执行第二步的时候，对于没有参加考试的学生记录就不会出现在vt2中，因为他们被on的逻辑表达式过滤掉了,但是我们用left outer join就可以把左表（学生）中没有参加考试的学生找回来，因为我们想返回的是x班级的所有学生，如果在on中应用学生.班级=’x’的话，left outer join会把x班级的所有学生记录找回，所以只能在where筛选器中应用学生.班级=’x’ 因为它的过滤是最终的。 </li><li>group by 子句将中的唯一的值组合成为一组，得到虚拟表vt5。如果应用了group by，那么后面的所有步骤都只能得到的vt5的列或者是聚合函数（count、sum、avg等）。原因在于最终的结果集中只为每个组包含一行。(这一步开始才可以使用select中的别名，他返回的是一个游标，而不是一个表，所以在where中不可以使用select中的别名，而having却可以使用)</li><li>应用cube或者rollup选项，为vt5生成超组，生成vt6. </li><li>应用having筛选器，生成vt7。having筛选器是第一个也是为唯一一个应用到已分组数据的筛选器。 </li><li>处理select子句。将vt7中的在select中出现的列筛选出来。生成vt8. </li><li>应用distinct子句，vt8中移除相同的行，生成vt9。事实上如果应用了group by子句那么distinct是多余的，原因同样在于，分组的时候是将列中唯一的值分成一组，同时只为每一组返回一行记录，那么所以的记录都将是不相同的。 </li><li>应用order by子句。按照order_by_condition排序vt9，此时返回的一个游标，而不是虚拟表。sql是基于集合的理论的，集合不会预先对他的行排序，它只是成员的逻辑集合，成员的顺序是无关紧要的。对表进行排序的查询可以返回一个对象，这个对象包含特定的物理顺序的逻辑组织。这个对象就叫游标。正因为返回值是游标，那么使用order by 子句查询不能应用于表表达式。排序是很需要成本的，除非你必须要排序，否则最好不要指定order by，最后，在这一步中是第一个也是唯一一个可以使用select列表中别名的步骤。 </li><li>应用top选项。此时才返回结果给请求者即用户。 </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SQL关键字执行顺序&quot;&gt;&lt;a href=&quot;#SQL关键字执行顺序&quot; class=&quot;headerlink&quot; title=&quot;SQL关键字执行顺序&quot;&gt;&lt;/a&gt;SQL关键字执行顺序&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;from&lt;/li&gt;
&lt;li&gt;join&lt;/li&gt;
&lt;li&gt;on &lt;
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://aemonswift.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="SQL" scheme="http://aemonswift.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/"/>
    
    
      <category term="数据库" scheme="http://aemonswift.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="SQL" scheme="http://aemonswift.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>数据库之分库分表</title>
    <link href="http://aemonswift.github.io/2019/11/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <id>http://aemonswift.github.io/2019/11/02/数据库之分库分表/</id>
    <published>2019-11-01T23:38:20.000Z</published>
    <updated>2019-11-04T00:48:38.217Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要分库分表"><a href="#为什么要分库分表" class="headerlink" title="为什么要分库分表"></a>为什么要分库分表</h1><p>就是跟着你的公司业务发展走的，你公司业务发展越好，用户就越多，数据量越大，请求量越大，那你单个数据库一定扛不住。</p><h2 id="分表-主要为了sql查询速度"><a href="#分表-主要为了sql查询速度" class="headerlink" title="分表(主要为了sql查询速度)"></a>分表(主要为了sql查询速度)</h2><p>比如你单表都几千万数据了，你确定你能扛住么？绝对不行，单表数据量太大，会极大影响你的 sql 执行的性能，到了后面你的 sql 可能就跑的很慢了。一般来说，就以我的经验来看，单表到几百万的时候，性能就会相对差一些了，你就得分表了。<br>分表是啥意思？就是把一个表的数据放到多个表中，然后查询的时候你就查一个表。比如按照用户 id 来分表，将一个用户的数据就放在一个表中。然后操作的时候你对一个用户就操作那个表就好了。这样可以控制每个表的数据量在可控的范围内，比如每个表就固定在 200 万以内。</p><h2 id="分库-主要为了并发度和磁盘使用情况"><a href="#分库-主要为了并发度和磁盘使用情况" class="headerlink" title="分库(主要为了并发度和磁盘使用情况)"></a>分库(主要为了并发度和磁盘使用情况)</h2><p>分库是啥意思？就是你一个库一般我们经验而言，最多支撑到并发 2000，一定要扩容了，而且一个健康的单库并发值你最好保持在每秒 1000 左右，不要太大。那么你可以将一个库的数据拆分到多个库中，访问的时候就访问一个库好了。<br>*||<br>:-:|:-:|:-:<br>并发支撑情况|MySQL 单机部署，扛不住高并发|    MySQL从单机到多机，能承受的并发增加了多倍<br>磁盘使用情况|    MySQL 单机磁盘容量几乎撑满|    拆分为多个库，数据库服务器磁盘使用率大大降低<br>SQL 执行性能|    单表数据量太大，SQL 越跑越慢|    单表数据量减少，SQL 执行效率明显提升</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么要分库分表&quot;&gt;&lt;a href=&quot;#为什么要分库分表&quot; class=&quot;headerlink&quot; title=&quot;为什么要分库分表&quot;&gt;&lt;/a&gt;为什么要分库分表&lt;/h1&gt;&lt;p&gt;就是跟着你的公司业务发展走的，你公司业务发展越好，用户就越多，数据量越大，请求量越大，那你单
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://aemonswift.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="分库分表" scheme="http://aemonswift.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    
    
      <category term="数据库" scheme="http://aemonswift.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="分库分表" scheme="http://aemonswift.github.io/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据库SQL分析工具</title>
    <link href="http://aemonswift.github.io/2019/11/01/%E6%95%B0%E6%8D%AE%E5%BA%93sql%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
    <id>http://aemonswift.github.io/2019/11/01/数据库sql分析工具/</id>
    <published>2019-11-01T08:03:43.000Z</published>
    <updated>2019-11-05T12:31:54.751Z</updated>
    
    <content type="html"><![CDATA[<p>主要是用explain工具来分析sql命中的情况</p><h1 id="explain之type字段"><a href="#explain之type字段" class="headerlink" title="explain之type字段"></a>explain之type字段</h1><p>官网描述为连接类型(the join type)。它描述了找到所需数据使用的$\color{red}{扫描方式。}$<br>常见的扫描方式如下：</p><ul><li>system：系统表，少量数据，往往不需要进行磁盘IO；</li><li>const：常量连接；</li><li>eq_ref：主键索引(primary key)或者非空唯一索引(unique not null)等值扫描；</li><li>ref：非主键非唯一索引等值扫描；</li><li>range：范围扫描；</li><li>index：索引树扫描；</li><li>ALL：全表扫描(full table scan)；<br>上面扫描方式由快到慢顺序：<br>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</li></ul><h2 id="system-——不需要走io"><a href="#system-——不需要走io" class="headerlink" title="system ——不需要走io"></a>system ——不需要走io</h2><p>从系统库mysql的系统表time_zone里查询数据，扫码类型为system，这些数据已经加载到内存里，不需要进行磁盘IO。 <code>explain select * from mysql.time_zone;</code><br>内层嵌套(const)返回了一个临时表，外层嵌套从临时表查询，其扫描类型也是system，也不需要走磁盘IO，速度超快。 <code>explain select * from (select * from user where id=1) tmp;</code></p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>成为const扫描的条件：且关系</p><ol><li>命中主键(primary key)或者唯一(unique)索引；</li><li>被连接的部分是一个常量(const)值；<br>例如：<code>explain select * from user where id=1;</code>id是PK，连接部分是常量1。<br>这类扫描效率极高，返回数据量少，速度非常快。</li></ol><h2 id="eq-ref"><a href="#eq-ref" class="headerlink" title="eq_ref"></a>eq_ref</h2><p>eq_ref扫描的条件为：对于前表的每一行(row)，后表只有一行被扫描。<br>再细化一点：</p><ol><li>join查询；</li><li>命中主键(primary key)或者非空唯一(unique not null)索引；</li><li>等值连接；<br>例如：  <code>explain select * from user,user_ex where user.id=user_ex.id;</code></li></ol><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p>eq_ref案例中的主键索引，改为普通非唯一(non unique)索引。<code>explain select * from user,user_ex where user.id=user_ex.id;</code>就由eq_ref降级为了ref，此时对于前表的每一行(row)，后表可能有多于一行的数据被扫描。<br><code>explain select * from user where id=1;</code>当id改为普通非唯一索引后，常量的连接查询，也由const降级为了ref，因为也可能有多于一行的数据被扫描。<br>ref扫描，可能出现在join里，也可能出现在单表普通索引里，每一次匹配可能有多行数据返回，虽然它比eq_ref要慢，但它仍然是一个很快的join类型。</p><h2 id="range"><a href="#range" class="headerlink" title="range"></a>range</h2><p>range扫描就比较好理解了，它是索引上的范围查询，它会在索引上扫码特定范围内的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">4</span>;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> idin(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span>&gt;<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>像上例中的between，in，&gt;都是典型的范围(range)查询。</p><h2 id="index"><a href="#index" class="headerlink" title="index"></a>index</h2><p>index类型，需要扫描索引上的全部数据。<br><code>explain count (*) from user;</code>id是主键，该count查询需要通过扫描索引上的全部数据来计数。</p><h2 id="all"><a href="#all" class="headerlink" title="all"></a>all</h2><p><code>explain select * from user,user_ex where user.id=user_ex.id;</code>如果id上不建索引，对于前表的每一行(row)，后表都要被全表扫描。</p><h1 id="id字段"><a href="#id字段" class="headerlink" title="id字段"></a>id字段</h1><ol><li>id相同，执行顺序由上至下</li><li>id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li><li>id相同不同，同时存在</li></ol><h1 id="select-type字段"><a href="#select-type字段" class="headerlink" title="select_type字段"></a>select_type字段</h1><p>分别用来表示查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询。</p><ul><li>SIMPLE 简单的select查询，查询中不包含子查询或者UNION</li><li>PRIMARY 查询中若包含任何复杂的子部分，最外层查询则被标记为PRIMARY</li><li>PRIMARY 查询中若包含任何复杂的子部分，最外层查询则被标记为PRIMARY</li><li>DERIVED 在FROM列表中包含的子查询被标记为DERIVED（衍生），MySQL会递归执行这些子查询，把结果放在临时表中</li><li>UNION 若第二个SELECT出现在UNION之后，则被标记为UNION：若UNION包含在FROM子句的子查询中，外层SELECT将被标记为：DERIVED</li><li>UNION RESULT  从UNION表获取结果的SELECT</li></ul><h1 id="table字段"><a href="#table字段" class="headerlink" title="table字段"></a>table字段</h1><p>指的就是当前执行的表</p><h1 id="possible-keys-和-key"><a href="#possible-keys-和-key" class="headerlink" title="possible_keys 和 key"></a>possible_keys 和 key</h1><p>possible_keys 显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。<br>key表示实际使用的索引，如果为NULL，则没有使用索引。（可能原因包括没有建立索引或索引失效）</p><h1 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h1><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度，在不损失精确性的情况下，长度越短越好。key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的。</p><h1 id="ref-1"><a href="#ref-1" class="headerlink" title="ref"></a>ref</h1><p>显示索引的那一列被使用了，如果可能的话，最好是一个常数。哪些列或常量被用于查找索引列上的值。</p><h1 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h1><p>根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数，也就是说，用的越少越好</p><h1 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h1><p>包含不适合在其他列中显式但十分重要的额外信息</p><h2 id="Using-filesort（九死一生）"><a href="#Using-filesort（九死一生）" class="headerlink" title="Using filesort（九死一生）"></a>Using filesort（九死一生）</h2><p>说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序”。</p><h2 id="Using-temporary（十死无生）"><a href="#Using-temporary（十死无生）" class="headerlink" title="Using temporary（十死无生）"></a>Using temporary（十死无生）</h2><p>使用了用临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于排序order by和分组查询group by。</p><h2 id="Using-index（发财了）"><a href="#Using-index（发财了）" class="headerlink" title="Using index（发财了）"></a>Using index（发财了）</h2><p>表示相应的select操作中使用了覆盖索引（Covering Index），避免访问了表的数据行，效率不错。如果同时出现using where，表明索引被用来执行索引键值的查找；如果没有同时出现using where，表明索引用来读取数据而非执行查找动作。</p><h2 id="Using-where"><a href="#Using-where" class="headerlink" title="Using where"></a>Using where</h2><p>表明使用了where过滤</p><h2 id="Using-join-buffer"><a href="#Using-join-buffer" class="headerlink" title="Using join buffer"></a>Using join buffer</h2><p>表明使用了连接缓存,比如说在查询的时候，多表join的次数非常多，那么将配置文件中的缓冲区的join buffer调大一些。</p><h2 id="impossible-where"><a href="#impossible-where" class="headerlink" title="impossible where"></a>impossible where</h2><p>where子句的值总是false，不能用来获取任何元组</p><h2 id="select-tables-optimized-away"><a href="#select-tables-optimized-away" class="headerlink" title="select tables optimized away"></a>select tables optimized away</h2><p>在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。</p><h2 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h2><p>优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作</p><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><ol><li>执行顺序1：select_type为UNION，说明第四个select是UNION里的第二个select，最先执行【select name,id from t2】</li><li>执行顺序2：id为3，是整个查询中第三个select的一部分。因查询包含在from中，所以为DERIVED【select id,name from t1 where other_column=”】</li><li>执行顺序3：select列表中的子查询select_type为subquery,为整个查询中的第二个select【select id from t3】</li><li>执行顺序4：id列为1，表示是UNION里的第一个select，select_type列的primary表示该查询为外层查询，table列被标记为<derived3>,表示查询结果来自一个衍生表，其中derived3中的3代表该查询衍生自第三个select查询，即id为3的select。【select d1.name …..】</li><li>执行顺序5：代表从UNION的临时表中读取行的阶段，table列的&lt; union1,4 &gt;表示用第一个和第四个select的结果进行UNION操作。【两个结果union操作】</li></ol><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="“列类型”与“where值类型”不符，不能命中索引，会导致全表扫描-full-table-scan-。"><a href="#“列类型”与“where值类型”不符，不能命中索引，会导致全表扫描-full-table-scan-。" class="headerlink" title="“列类型”与“where值类型”不符，不能命中索引，会导致全表扫描(full table scan)。"></a>“列类型”与“where值类型”不符，不能命中索引，会导致全表扫描(full table scan)。</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 (</span><br><span class="line">cell <span class="built_in">varchar</span>(<span class="number">3</span>) primary <span class="keyword">key</span></span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span> <span class="keyword">default</span> <span class="keyword">charset</span>=latin1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1(cell) <span class="keyword">values</span> (<span class="string">'111'</span>),(<span class="string">'222'</span>),(<span class="string">'333'</span>);</span><br></pre></td></tr></table></figure><p><code>explain select * from t1 where cell=111;</code>强制类型转换，不能命中索引，需要全表扫描，即3条记录(即explain中的rows字段)；<br><code>explain select * from t1 where cell=&#39;111&#39;;</code>类型相同，命中索引，1条记录；(即explain中的rows字段)</p><h2 id="相join的两个表的字符编码不同，不能命中索引，会导致笛卡尔积的循环计算（nested-loop）。"><a href="#相join的两个表的字符编码不同，不能命中索引，会导致笛卡尔积的循环计算（nested-loop）。" class="headerlink" title="相join的两个表的字符编码不同，不能命中索引，会导致笛卡尔积的循环计算（nested loop）。"></a>相join的两个表的字符编码不同，不能命中索引，会导致笛卡尔积的循环计算（nested loop）。</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 (</span><br><span class="line">cell <span class="built_in">varchar</span>(<span class="number">3</span>) primary <span class="keyword">key</span></span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1(cell) <span class="keyword">values</span> (<span class="string">'111'</span>),(<span class="string">'222'</span>),(<span class="string">'333'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 (</span><br><span class="line">cell <span class="built_in">varchar</span>(<span class="number">3</span>) primary <span class="keyword">key</span></span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span> <span class="keyword">default</span> <span class="keyword">charset</span>=latin1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(cell) <span class="keyword">values</span> (<span class="string">'111'</span>),(<span class="string">'222'</span>),(<span class="string">'333'</span>),(<span class="string">'444'</span>),(<span class="string">'555'</span>),(<span class="string">'666'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t3 (</span><br><span class="line">cell <span class="built_in">varchar</span>(<span class="number">3</span>) primary <span class="keyword">key</span></span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t3(cell) <span class="keyword">values</span> (<span class="string">'111'</span>),(<span class="string">'222'</span>),(<span class="string">'333'</span>),(<span class="string">'444'</span>),(<span class="string">'555'</span>),(<span class="string">'666'</span>);</span><br></pre></td></tr></table></figure><ol><li>t2和t1字符集不同，插入6条测试数据；</li><li>t3和t1字符集相同，也插入6条测试数据；</li><li>除此之外，t1，t2，t3表结构完全相同；<br><code>explain select * from t1,t2 where t1.cell=t2.cell;</code>第一个join，连表t1和t2（字符集不同），关联属性是cell；</li></ol><p><code>explain select * from t1,t3 where t1.cell=t3.cell;</code>第一个join，连表t1和t3（字符集相同），关联属性是cell；<br>测试结果：</p><ol><li>t1和t2字符集不同，存储空间不同；</li><li>t1和t2相join时，遍历了t1的所有记录3条，t1的每一条记录又要遍历t2的所有记录6条，实际进行了笛卡尔积循环计算(nested loop)，索引无效；</li><li>）t1和t3相join时，遍历了t1的所有记录3条，t1的每一条记录使用t3索引，即扫描1行记录；</li></ol><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://mp.weixin.qq.com/s/1Sowt2TcjMGDv55OQOe2rQ" target="_blank" rel="noopener">两类非常隐蔽的全表扫描，不能命中索引</a><br><a href="https://blog.csdn.net/why15732625998/article/details/80388236" target="_blank" rel="noopener">EXPLAIN用法和结果分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主要是用explain工具来分析sql命中的情况&lt;/p&gt;
&lt;h1 id=&quot;explain之type字段&quot;&gt;&lt;a href=&quot;#explain之type字段&quot; class=&quot;headerlink&quot; title=&quot;explain之type字段&quot;&gt;&lt;/a&gt;explain之type
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://aemonswift.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="分析工具" scheme="http://aemonswift.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="数据库" scheme="http://aemonswift.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="分析工具" scheme="http://aemonswift.github.io/tags/%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>数据库索引原理</title>
    <link href="http://aemonswift.github.io/2019/11/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/"/>
    <id>http://aemonswift.github.io/2019/11/01/数据库索引原理/</id>
    <published>2019-11-01T03:03:44.000Z</published>
    <updated>2019-11-04T00:48:38.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库为什么要选择B-树作为索引"><a href="#数据库为什么要选择B-树作为索引" class="headerlink" title="数据库为什么要选择B+树作为索引"></a>数据库为什么要选择B+树作为索引</h1><ol><li>数据库为什么需要索引</li></ol><p>数据库存储了1000W条数据，要从中找到name=”shenjian”的记录，一条条查，要查到什么时候去？于是，$\color{red}{要有索引，用于提升数据库的查找速度。}$</p><ol start="2"><li>哈希(hash)比树(tree)更快，索引结构为什么要设计成树型？<br>加速查找速度的数据结构，常见的有两类：</li></ol><ul><li>哈希，例如HashMap，查询/插入/修改/删除的平均时间复杂度都是O(1)；</li><li>树，例如平衡二叉搜索树，查询/插入/修改/删除的平均时间复杂度都是O(lg(n))；<br>可以看到，不管是读请求，还是写请求，哈希类型的索引，都要比树型的索引更快一些，那为什么，索引结构要设计成树型呢？<br>索引设计成树形，和SQL的需求相关。select * from t where name=”shenjian”，确实是哈希索引更快，因为每次都只查询一条记录。但是对于排序查询的SQL需求：分组（group by），排序（order by），比较（&gt;,&lt;）等，哈希型的索引，时间复杂度会退化为O(n)，而树型的“有序”特性，依然能够保持O(log(n)) 的高效率。</li></ul><h2 id="常见的树"><a href="#常见的树" class="headerlink" title="常见的树"></a>常见的树</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>当数据量大的时候，树的高度会比较高，数据量大的时候，查询会比较慢；每个节点只存储一个记录，可能导致一次查询有很多次磁盘IO；</p><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>特点：<br>a. 不再是二叉搜索，而是m叉搜索；<br>b. 叶子节点，非叶子节点，都存储数据；<br>c. 中序遍历，可以获得所有节点；<br>B树被作为实现索引的数据结构被创造出来，是因为它能够完美的利用“局部性原理”。(所谓局部性原理：1. 内存读写块，磁盘读写慢，而且慢很多；2. 磁盘预读：磁盘读写并不是按需读取，而是按页预读，一次会读一页的数据，每次加载更多的数据，如果未来要读取的数据就在这一页中，可以避免未来的磁盘IO，提高效率；3. 局部性原理：软件设计要尽量遵循“数据读取集中”与“使用到一个数据，大概率会使用其附近的数据”，这样磁盘预读能充分提高磁盘IO；)<br>B树为何适合做索引：1. 由于是m分叉的，高度能够大大降低；2. 每个节点可以存储j个记录，如果将节点大小设置为页大小，例如4K，能够充分的利用预读的特性，极大减少磁盘IO；</p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>仍是m叉搜索树，在B树的基础上，做了一些改进：</p><ol><li>非叶子节点不再存储数据，数据只存储在同一层的叶子节点上；（B+树中根到每一个节点的路径长度一样，而B树不是这样。）</li><li>叶子之间，增加了链表，获取所有节点，不再需要中序遍历；<br>与B树相比，优势：</li><li>范围查找，定位min与max之后，中间叶子节点，就是结果集，不用中序回溯；</li><li>叶子节点存储实际记录行，记录行相对比较紧密的存储，适合大数据量磁盘存储；非叶子节点存储记录的PK，用于查询加速，适合内存存储；</li><li>非叶子节点，不存储实际记录，而只存储记录的KEY的话，那么在相同内存的情况下，B+树能够存储更多索引；<h2 id="选择B-树的原因"><a href="#选择B-树的原因" class="headerlink" title="选择B+树的原因"></a>选择B+树的原因</h2></li><li>数据库索引用于加速查询</li><li>虽然哈希索引是O(1)，树索引是O(log(n))，但SQL有很多“有序”需求，故数据库使用树型索引</li><li>数据预读的思路是：磁盘读写并不是按需读取，而是按页预读，一次会读一页的数据，每次加载更多的数据，以便未来减少磁盘IO</li><li>局部性原理：软件设计要尽量遵循“数据读取集中”与“使用到一个数据，大概率会使用其附近的数据”，这样磁盘预读能充分提高磁盘IO</li><li>很低的树高度，能够存储大量数据；</li><li>索引本身占用的内存很小；</li><li>能够很好的支持单点查询，范围查询，有序性查询；</li><li>InnoDB不支持哈希索引</li></ol><h1 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a>聚集索引与非聚集索引</h1><ul><li>非聚集索引：索引与行记录是分开存储的</li><li>聚集索引：主键索引与行记录是存储在一起的</li></ul><h2 id="MyISAM索引"><a href="#MyISAM索引" class="headerlink" title="MyISAM索引"></a>MyISAM索引</h2><p>其主键索引与普通索引没有本质差异：（MyISAM的表可以没有主键。）</p><ol><li>有连续聚集的区域单独存储行记录</li><li>主键索引的叶子节点，存储主键和对应行记录的指针</li><li>普通索引的叶子结点，存储索引列和对应行记录的指针</li></ol><h2 id="InnoDB索引"><a href="#InnoDB索引" class="headerlink" title="InnoDB索引"></a>InnoDB索引</h2><p>InnoDB必须要有聚集索引，行记录按照聚集索引物理上排序。必须要有聚集索引，并不代表一定要有主键。<br>InnoDB的主键索引与行记录是存储在一起的，</p><ol><li>没有单独区域存储行记录</li><li>主键索引的叶子节点，存储主键和对应行记录（而不是指针）<br>因此，InnoDB的PK查询是非常快的。<br>因为这个特性，InnoDB必须有聚集索引：</li><li>如果表定义了主键，则PK就是聚集索引；</li><li>如果没有主键被定义，那么该表的第一个唯一非空索引被作为聚集索引。</li><li>如果没有主键也没有合适的唯一索引，那么innodb内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键是一个6个字节的列，该列的值会随着数据的插入自增。<br>聚集索引，也只能够有一个，因为数据行在物理磁盘上只能有一份聚集存储。<br>InnoDB的普通索引可以有多个，它与聚集索引是不同的：</li><li>普通索引的叶子节点，存储索引列和主键（也不是指针）<br>对于InnoDB表，这里的启示是：</li><li>不建议使用较长的列做主键，例如char(64)，因为所有的普通索引都会存储主键，会导致普通索引过于庞大；</li><li>建议使用趋势递增的key做主键，由于数据行与索引一体，这样不至于插入记录时，有大量索引分裂，行记录移动；</li></ol><h2 id="主键的选择"><a href="#主键的选择" class="headerlink" title="主键的选择"></a>主键的选择</h2><ol><li>不能为空的列</li><li>不能重复的列</li><li>很少改变的列：行是按照聚集索引物理排序的，如果主键频繁改变，物理顺序会改变，性能会急剧降低。</li><li>经常被检索的列：被检索的列上要建立索引，如果该索引是聚集索引，能够避免回表，性能提升几乎一倍。</li><li>不是太长的列：普通索引叶子节点会存储主键值，如果主键值太长，会增加普通索引的大小。</li></ol><h3 id="主键和聚集索引的区别"><a href="#主键和聚集索引的区别" class="headerlink" title="主键和聚集索引的区别"></a>主键和聚集索引的区别</h3><ol><li>InnoDB一定会存在聚集索引的，故建立表的时候可以没有主键，其聚集索引如何选择，见上述描述。</li><li>建立表时若不声明主键非空，InnoDB会自动添加非空(not null)且唯一(unique)的限制。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(1) <span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">         <span class="keyword">id</span> <span class="built_in">int</span>,</span><br><span class="line">         <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>),</span><br><span class="line">         primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br><span class="line">(2) <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="string">'shenjian'</span>);</span><br><span class="line">(3) <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="string">'shenjian'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行第三行的时候会报错，产生主键冲突</span></span><br><span class="line"><span class="comment"># 执行show create table命令查看表时，发现表结构为：</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">         <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line">         <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">         primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br></pre></td></tr></table></figure></li><li>建立表的时候，可以选择多个字段作为主键——只要满足聚集索引的要求即可。</li><li>建立表的时候可以单独使用自增主键，插入记录的时候也可以插入主键id（但要保证主键不能冲突）</li><li>建立表的时候使用联合自增主键时注意设置主键的顺序——必须保证自增主键在第一列。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">         <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> auto_increment,</span><br><span class="line">         <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">         primary <span class="keyword">key</span>(<span class="keyword">name</span>,<span class="keyword">id</span>), <span class="comment">#使用这个主键，建表将会报错</span></span><br><span class="line">         primary <span class="keyword">key</span>(<span class="keyword">id</span>,<span class="keyword">name</span>), <span class="comment"># 使用此主键，建表正确（必须保证自增主键在第一列）</span></span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br></pre></td></tr></table></figure>例如：<code>select * from t where name=‘lisi’;</code>会先通过name辅助索引定位到B+树的叶子节点得到id=5，再通过聚集索引定位到行记录。——扫描列两次索引树。<br>如何解决扫描两次索引树得到结果？——索引覆盖</li></ol><h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><p>$\color{red}{索引覆盖：}$只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。<br>使用explain查询sql命中的索引时，即explain的输出结果Extra字段为Using index时，能够触发索引覆盖。<br>解决方法：建立两列以上的索引，查询复合索引里的列的数据不需要进行回表二次查询，如index(col1, col2)，执行下面的语句：(主键id可以例外：因为叶子节点存储了索引列和主键id)<br><code>select col1, col2 from t1 where col1 = &#39;213&#39;;</code></p><h4 id="哪些场景可以利用索引覆盖来优化SQL？"><a href="#哪些场景可以利用索引覆盖来优化SQL？" class="headerlink" title="哪些场景可以利用索引覆盖来优化SQL？"></a>哪些场景可以利用索引覆盖来优化SQL？</h4><ol><li>全表count查询优化  <code>select count(name) from user</code>,只要name可以进行索引，就会输出结果Extra字段为Using index（索引覆盖）</li><li>列查询回表优化——将单列索引(name)升级为联合索引(name, sex)，即可避免回表。<code>select id,name,sex ... where name=&#39;shenjian&#39;;</code></li><li>分页查询。<code>select id,name,sex ... order by name limit 500,100;</code>将单列索引(name)升级为联合索引(name, sex)，也可以避免回表。</li></ol><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://mp.weixin.qq.com/s/FUXPXKfKyjxAvMUFHZm9UQ" target="_blank" rel="noopener">1分钟了解MyISAM与InnoDB的索引差异</a><br><a href="https://mp.weixin.qq.com/s/YMbRJwyjutGMD1KpI_fS0A" target="_blank" rel="noopener">数据库索引，到底是什么做的？</a><br><a href="https://www.jianshu.com/p/3cd3cec2e28c" target="_blank" rel="noopener">Mysql的聚集索引与辅助索引</a><br><a href="https://mp.weixin.qq.com/s/y0pjtNUZhOW2ZBOy4m-xsA" target="_blank" rel="noopener">如何避免回表查询？什么是索引覆盖？</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库为什么要选择B-树作为索引&quot;&gt;&lt;a href=&quot;#数据库为什么要选择B-树作为索引&quot; class=&quot;headerlink&quot; title=&quot;数据库为什么要选择B+树作为索引&quot;&gt;&lt;/a&gt;数据库为什么要选择B+树作为索引&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;数据库为什么需要
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://aemonswift.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="索引" scheme="http://aemonswift.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%B4%A2%E5%BC%95/"/>
    
    
      <category term="数据库" scheme="http://aemonswift.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="索引" scheme="http://aemonswift.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>布谷鸟过滤器</title>
    <link href="http://aemonswift.github.io/2019/11/01/%E5%B8%83%E8%B0%B7%E9%B8%9F%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>http://aemonswift.github.io/2019/11/01/布谷鸟过滤器/</id>
    <published>2019-11-01T02:38:18.000Z</published>
    <updated>2019-11-01T02:53:43.404Z</updated>
    
    <content type="html"><![CDATA[<p>为了解决布隆过滤器不能删除元素的问题，布谷鸟过滤器横空出世。相比布谷鸟过滤器而言布隆过滤器有以下不足：查询性能弱、空间利用效率低、不支持反向操作（删除）以及不支持计数。<br>查询性能弱是因为布隆过滤器需要使用多个 hash 函数探测位图中多个不同的位点，这些位点在内存上跨度很大，会导致 CPU 缓存行命中率低。<br>空间效率低是因为在相同的误判率下，布谷鸟过滤器的空间利用率要明显高于布隆，空间上大概能节省 40% 多。不过布隆过滤器并没有要求位图的长度必须是 2 的指数，而布谷鸟过滤器必须有这个要求。从这一点出发，似乎布隆过滤器的空间伸缩性更强一些。<br>不支持反向删除操作这个问题着实是击中了布隆过滤器的软肋。在一个动态的系统里面元素总是不断的来也是不断的走。布隆过滤器就好比是印迹，来过来就会有痕迹，就算走了也无法清理干净。比如你的系统里本来只留下 1kw 个元素，但是整体上来过了上亿的流水元素，布隆过滤器很无奈，它会将这些流失的元素的印迹也会永远存放在那里。随着时间的流失，这个过滤器会越来越拥挤，直到有一天你发现它的误判率太高了，不得不进行重建。</p><p>但布谷鸟过滤器它支持的反向删除操作非常鸡肋，以至于你根本没办法使用这个功能。 </p><h1 id="布谷鸟哈希算法原理"><a href="#布谷鸟哈希算法原理" class="headerlink" title="布谷鸟哈希算法原理"></a>布谷鸟哈希算法原理</h1><p>布谷鸟过滤器源于布谷鸟哈希算法，布谷鸟哈希算法源于生活 —— 那个热爱「鸠占鹊巢」的布谷鸟。布谷鸟喜欢滥交（自由），从来不自己筑巢。它将自己的蛋产在别人的巢里，让别人来帮忙孵化。待小布谷鸟破壳而出之后，因为布谷鸟的体型相对较大，它又将养母的其它孩子（还是蛋）从巢里挤走 —— 从高空摔下夭折了。<br>最简单的布谷鸟哈希结构是一维数组结构，会有两个 hash 算法将新来的元素映射到数组的两个位置。如果两个位置中有一个位置为空，那么就可以将元素直接放进去。但是如果这两个位置都满了，它就不得不「鸠占鹊巢」，随机踢走一个，然后自己霸占了这个位置。<br>不同于布谷鸟的是，布谷鸟哈希算法会帮这些受害者（被挤走的蛋）寻找其它的窝。因为每一个元素都可以放在两个位置，只要任意一个有空位置，就可以塞进去。所以这个伤心的被挤走的蛋会看看自己的另一个位置有没有空，如果空了，自己挪过去也就皆大欢喜了。但是如果这个位置也被别人占了呢？好，那么它会再来一次「鸠占鹊巢」，将受害者的角色转嫁给别人。然后这个新的受害者还会重复这个过程直到所有的蛋都找到了自己的巢为止。<br>但是会遇到一个问题，那就是如果数组太拥挤了，连续踢来踢去几百次还没有停下来，这时候会严重影响插入效率。这时候布谷鸟哈希会设置一个阈值，当连续占巢行为超出了某个阈值，就认为这个数组已经几乎满了。这时候就需要对它进行扩容，重新放置所有元素。<br>还会有另一个问题，那就是可能会存在挤兑循环。比如两个不同的元素，hash 之后的两个位置正好相同，这时候它们一人一个位置没有问题。但是这时候来了第三个元素，它 hash 之后的位置也和它们一样，很明显，这时候会出现挤兑的循环。不过让三个不同的元素经过两次 hash 后位置还一样，这样的概率并不是很高，除非你的 hash 算法太差了。<br>布谷鸟哈希算法对待这种挤兑循环的态度就是认为数组太拥挤了，需要扩容（实际上并不是这样）。</p><h1 id="布谷鸟哈希算法优化"><a href="#布谷鸟哈希算法优化" class="headerlink" title="布谷鸟哈希算法优化"></a>布谷鸟哈希算法优化</h1><p>上面的布谷鸟哈希算法的平均空间利用率并不高，大概只有 50%。到了这个百分比，就会很快出现连续挤兑次数超出阈值。这样的哈希算法价值并不明显，所以需要对它进行改良。<br>改良的方案之一是增加 hash 函数，让每个元素不止有两个巢，而是三个巢、四个巢。这样可以大大降低碰撞的概率，将空间利用率提高到 95%左右。<br>另一个改良方案是在数组的每个位置上挂上多个座位，这样即使两个元素被 hash 在了同一个位置，也不必立即「鸠占鹊巢」，因为这里有多个座位，你可以随意坐一个。除非这多个座位都被占了，才需要进行挤兑。很明显这也会显著降低挤兑次数。这种方案的空间利用率只有 85%左右，但是查询效率会很高，同一个位置上的多个座位在内存空间上是连续的，可以有效利用 CPU 高速缓存。<br>所以更加高效的方案是将上面的两个改良方案融合起来，比如使用 4 个 hash 函数，每个位置上放 2 个座位。这样既可以得到时间效率，又可以得到空间效率。这样的组合甚至可以将空间利用率提到高 99%，这是非常了不起的空间效率。</p><h1 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h1><p>假设有一段文本数据，我们把它通过cuckoo filter导入到一个虚拟的flash中，再把它导出到另一个文本文件中。flash存储的单元页面是一个log_entry，里面包含了一对key/value，value就是文本数据，key就是这段大小的数据的SHA1值（照理说SHA1是可以通过数据源生成，没必要存储到flash，但这里主要为了测试而故意设计的，万一key和value之间没有推导关系呢）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECTOR_SIZE    (1 &lt;&lt; 10)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DAT_LEN        (SECTOR_SIZE - 20)  <span class="comment">/* 减去20主要是为了给sha1使用*/</span></span></span><br><span class="line"><span class="comment">/* The log entries store key-value pairs on flash and the</span></span><br><span class="line"><span class="comment"> * size of each entry is assumed just one sector fit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">log_entry</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint8_t</span> sha1[<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">uint8_t</span> data[DAT_LEN];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>顺便说明一下DAT_LEN设置，之前我们设计了一个虚拟flash（用malloc模拟出来），由于flash的单位是按页大小SECTOR_SIZE读写，这里假设每个log_entry正好一个页大小，当然可以根据实际情况调整。<br>至于哈希表里的slot有三个成员tag，status和offset，分别是哈希值，状态值和在flash的偏移位置。其中status有三个枚举值：AVAILIBLE，OCCUPIED，DELETED，分别表示这个slot是空闲的，占用的还是被删除的。$\color{red}{至于tag，按理说应该有两个哈希值，对应两个哈希函数，但其中一个已经对应bucket的位置上了，所以我们只要保存另一个备用bucket的位置就行了}$，这样万一被踢，只要用这个tag就可以找到它的另一个安身之所。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; AVAILIBLE, OCCUPIED, DELETED, &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* The in-memory hash bucket cache is to filter keys (which is assumed SHA1) via</span></span><br><span class="line"><span class="comment"> * cuckoo hashing function and map keys to log entries stored on flash.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash_slot_cache</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> tag : <span class="number">30</span>;  <span class="comment">/* summary of key */</span></span><br><span class="line">        <span class="keyword">uint32_t</span> status : <span class="number">2</span>;  <span class="comment">/* FSM */</span></span><br><span class="line">        <span class="keyword">uint32_t</span> offset;  <span class="comment">/* offset on flash memory */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>乍看之下size有点大是吗？没关系，你也可以根据情况调整数据类型大小，比如uint16_t，这里仅仅为了测试正确性。<br>至于哈希表以及bucket和slot的创建见初始化代码。buckets是一个二级指针，每个bucket指向4个slot大小的缓存，即4路slot，那么bucket_num也就是slot_num的1/4。这里我们故意把slot_num调小了点，为的是测试rehash的发生。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASSOC_WAY  (4)  <span class="comment">/* 4-way association */</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash_table</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hash_slot_cache</span> **<span class="title">buckets</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hash_slot_cache</span> *<span class="title">slots</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> slot_num;</span><br><span class="line">    <span class="keyword">uint32_t</span> bucket_num;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cuckoo_filter_init</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* Allocate hash slots */</span></span><br><span class="line">    hash_table.slot_num = size / SECTOR_SIZE;</span><br><span class="line">    <span class="comment">/* Make rehashing happen */</span></span><br><span class="line">    hash_table.slot_num /= <span class="number">4</span>;</span><br><span class="line">    hash_table.slots = <span class="built_in">calloc</span>(hash_table.slot_num, <span class="keyword">sizeof</span>(struct hash_slot_cache));</span><br><span class="line">    <span class="keyword">if</span> (hash_table.slots == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Allocate hash buckets associated with slots */</span></span><br><span class="line">    hash_table.bucket_num = hash_table.slot_num / ASSOC_WAY;</span><br><span class="line">    hash_table.buckets = <span class="built_in">malloc</span>(hash_table.bucket_num * <span class="keyword">sizeof</span>(struct hash_slot_cache *));</span><br><span class="line">    <span class="keyword">if</span> (hash_table.buckets == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span>(hash_table.slots);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; hash_table.bucket_num; i++) &#123;</span><br><span class="line">        hash_table.buckets[i] = &amp;hash_table.slots[i * ASSOC_WAY];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是哈希函数的设计，这里有两个，前面提到既然key是20字节的SHA1值，我们就可以分别是对key的低32位和高32位进行位运算，只要bucket_num满足2的幂次方，我们就可以将key的一部分同bucket_num – 1相与，就可以定位到相应的bucket位置上，注意bucket_num随着rehash而增大，哈希函数简单的好处是求哈希值十分快。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cuckoo_hash_lsb(key, count)  (((size_t *)(key))[0] &amp; (count - 1))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cuckoo_hash_msb(key, count)  (((size_t *)(key))[1] &amp; (count - 1))</span></span><br></pre></td></tr></table></figure><p>终于要讲解cuckoo filter最重要的三个操作了——查询、插入还有删除。查询操作是简单的，我们对传进来的参数key进行两次哈希求值tag[0]和tag[1]，并先用tag[0]定位到bucket的位置，从4路slot中再去对比tag[1]。只有比中了tag后，由于只是key的一部分，我们再去从flash中验证完整的key，并把数据在flash中的偏移值read_addr输出返回。相应的，如果bucket[tag[0]]的4路slot都没有比中，我们再去bucket[tag[1]]中比对（代码略），如果还比不中，可以肯定这个key不存在。$\color{red}{这种设计的好处就是减少了不必要的flash读操作，每次比对的是内存中的tag而不需要完整的key。}</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cuckoo_hash_get</span><span class="params">(struct hash_table *table, <span class="keyword">uint8_t</span> *key, <span class="keyword">uint8_t</span> **read_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">uint8_t</span> *addr;</span><br><span class="line">    <span class="keyword">uint32_t</span> tag[<span class="number">2</span>], offset;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hash_slot_cache</span> *<span class="title">slot</span>;</span></span><br><span class="line"> </span><br><span class="line">    tag[<span class="number">0</span>] = cuckoo_hash_lsb(key, table-&gt;bucket_num);</span><br><span class="line">    tag[<span class="number">1</span>] = cuckoo_hash_msb(key, table-&gt;bucket_num);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Filter the key and verify if it exists. */</span></span><br><span class="line">    slot = table-&amp;gt;buckets[tag[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i bucket_num) == slot[i].tag) &#123;</span><br><span class="line">        <span class="keyword">if</span> (slot[i].status == OCCUPIED) &#123;</span><br><span class="line">            offset = slot[i].offset;</span><br><span class="line">            addr = key_verify(key, offset);</span><br><span class="line">            <span class="keyword">if</span> (addr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (read_addr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    *read_addr = addr;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (slot[i].status == DELETED) &#123;</span><br><span class="line">            <span class="keyword">return</span> DELETED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来先将简单的删除操作，之所以简单是因为delete除了将相应slot的状态值设置一下之外，其实什么都没有干，也就是说它不会真正到flash里面去把数据清除掉。为什么？很简单，没有必要。还有一个原因，flash的写操作之前需要擦除整个页面，这种擦除是会折寿的，$\color{red}{所以很多flash支持随机读，但必须保持顺序写。}$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cuckoo_hash_delete</span><span class="params">(struct hash_table *table, <span class="keyword">uint8_t</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> i, j, tag[<span class="number">2</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hash_slot_cache</span> *<span class="title">slot</span>;</span></span><br><span class="line"> </span><br><span class="line">    tag[<span class="number">0</span>] = cuckoo_hash_lsb(key, table-&gt;bucket_num);</span><br><span class="line">    tag[<span class="number">1</span>] = cuckoo_hash_msb(key, table-&gt;bucket_num);</span><br><span class="line"> </span><br><span class="line">    slot = table-&gt;buckets[tag[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i bucket_num) == slot[i].tag) &#123;</span><br><span class="line">        slot[i].status = DELETED;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解了flash的读写特性，你就知道为啥插入操作在flash层面要设计成append。不过我们这里不讨论过多flash细节，哈希表层面的插入逻辑其实跟查询差不多，我就不贴代码了。这里要贴的是如何判断并处理碰撞，其实这里也没啥玄机，就是用old_tag和old_offset保存一下临时变量，以便一个元素被踢出去之后还能找到备用的安身之所。但这里会有一个判断，每次踢人都会计数，当alt_cnt大于512时候表示哈希表真的快满了，这时候需要rehash了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cuckoo_hash_collide</span><span class="params">(struct hash_table *table, <span class="keyword">uint32_t</span> *tag, <span class="keyword">uint32_t</span> *p_offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, alt_cnt;</span><br><span class="line">    <span class="keyword">uint32_t</span> old_tag[<span class="number">2</span>], offset, old_offset;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hash_slot_cache</span> *<span class="title">slot</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Kick out the old bucket and move it to the alternative bucket. */</span></span><br><span class="line">    offset = *p_offset;</span><br><span class="line">    slot = table-&gt;buckets[tag[<span class="number">0</span>]];</span><br><span class="line">    old_tag[<span class="number">0</span>] = tag[<span class="number">0</span>];</span><br><span class="line">    old_tag[<span class="number">1</span>] = slot[<span class="number">0</span>].tag;</span><br><span class="line">    old_offset = slot[<span class="number">0</span>].offset;</span><br><span class="line">    slot[<span class="number">0</span>].tag = tag[<span class="number">1</span>];</span><br><span class="line">    slot[<span class="number">0</span>].offset = offset;</span><br><span class="line">    i = <span class="number">0</span> ^ <span class="number">1</span>;</span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    alt_cnt = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">KICK_OUT:</span><br><span class="line">    slot = table-&gt;buckets[old_tag[i]];</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ASSOC_WAY; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (offset == INVALID_OFFSET &amp;&amp; slot[j].status == DELETED) &#123;</span><br><span class="line">            slot[j].status = OCCUPIED;</span><br><span class="line">            slot[j].tag = old_tag[i ^ <span class="number">1</span>];</span><br><span class="line">            *p_offset = offset = slot[j].offset;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (slot[j].status == AVAILIBLE) &#123;</span><br><span class="line">            slot[j].status = OCCUPIED;</span><br><span class="line">            slot[j].tag = old_tag[i ^ <span class="number">1</span>];</span><br><span class="line">            slot[j].offset = old_offset;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (j == ASSOC_WAY) &#123;</span><br><span class="line">        <span class="keyword">if</span> (++alt_cnt &gt; <span class="number">512</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k == ASSOC_WAY - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">/* Hash table is almost full and needs to be resized */</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">uint32_t</span> tmp_tag = slot[k].tag;</span><br><span class="line">        <span class="keyword">uint32_t</span> tmp_offset = slot[k].offset;</span><br><span class="line">        slot[k].tag = old_tag[i ^ <span class="number">1</span>];</span><br><span class="line">        slot[k].offset = old_offset;</span><br><span class="line">        old_tag[i ^ <span class="number">1</span>] = tmp_tag;</span><br><span class="line">        old_offset = tmp_offset;</span><br><span class="line">        i ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> KICK_OUT;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rehash的逻辑也很简单，无非就是把哈希表中的buckets和slots重新realloc一下，空间扩展一倍，然后再从flash中的key重新插入到新的哈希表里去。这里有个陷阱要注意，千万不能有相同的key混进来！虽然cuckoo hashing不像开链法那样会退化成O(n)，但由于每个元素有两个哈希值，而且每次计算的哈希值随着哈希表rehash的规模而不同，相同的key并不能立即检测到冲突，但当相同的key达到一定规模后，噩梦就开始了，由于rehash里面有插入操作，一旦在这里触发碰撞，又会触发rehash，这时就是一个rehash不断递归的过程，由于其中老的内存没释放，新的内存不断重新分配，整个程序就如同陷入DoS攻击一般瘫痪了。所以每次插入操作前一定要判断一下key是否已经存在过，并且对rehash里的插入使用碰撞断言防止此类情况发生。笔者在测试中不幸中了这样的彩蛋，调试了大半天才搞清楚原因，搞IT的同学们记住一定要防小人啊~</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cuckoo_rehash</span><span class="params">(struct hash_table *table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">uint8_t</span> *read_addr = nvrom_base_addr;</span><br><span class="line">    <span class="keyword">uint32_t</span> entries = log_entries;</span><br><span class="line">    <span class="keyword">while</span> (entries--) &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> key[<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">uint32_t</span> offset = read_addr - nvrom_base_addr;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &amp;lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            key[i] = flash_read(read_addr);</span><br><span class="line">            read_addr++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Duplicated keys in hash table which can cause eternal</span></span><br><span class="line"><span class="comment">         * hashing collision! Be careful of that!</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        assert(!cuckoo_hash_put(table, key, &amp;offset));</span><br><span class="line">        <span class="keyword">if</span> (cuckoo_hash_get(&amp;old_table, key, <span class="literal">NULL</span>) == DELETED) &#123;</span><br><span class="line">            cuckoo_hash_delete(table, key);</span><br><span class="line">        &#125;</span><br><span class="line">        read_addr += DAT_LEN;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://juejin.im/post/5cfb9c74e51d455d6d5357db" target="_blank" rel="noopener">布隆过滤器过时了，未来属于布谷鸟过滤器？</a><br><a href="https://coolshell.cn/articles/17225.html" target="_blank" rel="noopener">CUCKOO FILTER：设计与实现</a><br><a href="https://github.com/begeekmyfriend/CuckooFilter" target="_blank" rel="noopener">布隆过滤器实现C++</a><br><a href="https://github.com/seiflotfy/cuckoofilter" target="_blank" rel="noopener">布隆过滤器实现go</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了解决布隆过滤器不能删除元素的问题，布谷鸟过滤器横空出世。相比布谷鸟过滤器而言布隆过滤器有以下不足：查询性能弱、空间利用效率低、不支持反向操作（删除）以及不支持计数。&lt;br&gt;查询性能弱是因为布隆过滤器需要使用多个 hash 函数探测位图中多个不同的位点，这些位点在内存上跨
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>布隆过滤器</title>
    <link href="http://aemonswift.github.io/2019/10/31/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>http://aemonswift.github.io/2019/10/31/布隆过滤器/</id>
    <published>2019-10-31T11:38:18.000Z</published>
    <updated>2019-10-31T11:45:54.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>假设你现在要处理这样一个问题，你有一个网站并且拥有很多访客，每当有用户访问时，你想知道这个ip是不是第一次访问你的网站。这是一个很常见的场景，为了完成这个功能，你很容易就会想到下面这个解决方案：<br>把访客的ip存进一个hash表中，每当有新的访客到来时，先检查哈希表中是否有改访客的ip，如果有则说明该访客在黑名单中。你还知道，hash表的存取时间复杂度都是O(1),效率很高，因此你对你的方案很是满意。<br>然后我们假设你的网站已经被1亿个用户访问过，每个ip的长度是15，那么你一共需要$15 * 100000000 = 1500000000Bytes = 1.4G$，这还没考虑hash冲突的问题（hash表中的槽位越多，越浪费空间，槽位越少，效率越低）。<br>于是聪明的你稍一思考，又想到可以把ip转换成无符号的int型值来存储，这样一个ip只需要占用4个字节就行了，这时1亿个ip占用的空间是$4 * 100000000 = 400000000Bytes = 380M$，空间消耗降低了很多。<br>那还有没有在不影响存取效率的前提下更加节省空间的办法呢?</p><h1 id="BitSet"><a href="#BitSet" class="headerlink" title="BitSet"></a>BitSet</h1><p>32位无符号int型能表示的最大值是4294967295，所有的ip都在这个范围内，我们可以用一个bit位来表示某个ip是否出现过，如果出现过，就把代表该ip的bit位置为1，那么我们最多需要429496729个bit就可以表示所有的ip了。举个例子比如10.0.0.1转换成int是167772161，那么把长度为4294967295的bit数组的第167772161个位置置为1即可，当有ip访问时，只需要检查该标志位是否为1就行了。<code>4294967295bit = 536870912Byte = 512M</code>。如果用hash表示所有4294967295范围内的数组的话，需要十几G的空间。<br>当然，这里举ip的例子不一定合适，主要目的是为了引出BitSet。</p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>例子：首先，比如我们有一个长度=2的byte数组，2个字节一共有16位，可以表示0-15的数字是否存在。比如我们要验证11是否出现过，那么我们先检查第11个位置是否为1，如果为0，说明11没出现过，然后我们把第11位置为1，表示11已经出现过了。<br>故BitSet基本只有两个操作，set(int value) 和 isHas(int value)</p><h3 id="set-int-value"><a href="#set-int-value" class="headerlink" title="set(int value)"></a>set(int value)</h3><p>我们先来看set怎么实现，因为一个byte占8位，所以对于一个给定的value，我们先求出该value应该位于哪个Byte上，这很简单，int byteIndex = value / 8;<br>找到value在byte数组中的位置后，再就是在该字节中寻找表示value的bit位，我们知道，一个byte其实就是一个长为8的bit数组，那么value在该bit数组中的位置也就很好算了，int bitIndex = value % 8;<br>最后我们把该bit位设置为1就可以了：byte[byteIndex] = byte[byteIndex] | 1 &lt;&lt; ( 7 - bitIndex)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> byteIndex = value / <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">int</span> bitIndex = value % <span class="number">8</span>;</span><br><span class="line">  byte[byteIndex] = byte[byteIndex] | <span class="number">1</span> &lt;&lt; (<span class="number">7</span> - bitIndex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isHas-int-value"><a href="#isHas-int-value" class="headerlink" title="isHas(int value)"></a>isHas(int value)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isHash</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> byteIndex = value / <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">int</span> bitIndex = value % <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">return</span> byte[byteIndex] &amp; <span class="number">1</span> &lt;&lt; (<span class="number">7</span> - bitIndex) &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$\color{red}{例子：}$<br><img alt="BitSet例子" data-src="https://cdn.jsdelivr.net/gh/AemonSwift/AemonSwift@latest/AemonSwift.github.io/images/bloom-filter1.png" class="lozad"><br>比如我们有一个长度=2的byte数组，2个字节一共有16位，可以表示0-15的数字是否存在。比如我们要验证11是否出现过，那么我们先检查第11个位置是否为1，如果为0，说明11没出现过，然后我们把第11位置为1，表示11已经出现过了。</p><h2 id="BitSet的局限性"><a href="#BitSet的局限性" class="headerlink" title="BitSet的局限性"></a>BitSet的局限性</h2><ol><li>当样本分布极度不均匀的时候，BitSet会造成很大空间上的浪费。比如你有10个数，分别是1、2、3、4、5、6、7、8、99999999999；那么你不得不用99999999999个bit位去实现你的BitSet,而这个BitSet的中间绝大多数位置都是0，并且永远不会用到，这显然是极度不划算的.</li><li>当元素不是整型的时候，BitSet就不适用了。若你拿到的是一堆url，然后如果你想用BitSet做去重的话，先得把url转换成int型，在转换的过程中难免某些url会计算出相同的int值，于是BitSet的准确性就会降低。<br>那针对这两种情况有没有解决办法呢？<br>第一种分布不均匀的情况可以通过hash函数，将元素都映射到一个区间范围内，减少大段区间闲置造成的浪费，这很简单，取模就好了，难的是取模之后的值保证不相同，即不发生hash冲突。<br>第二种情况，把字符串映射成整数是必要的，那么唯一要做的就是保证我们的hash函数尽可能的减少hash冲突，一次不行我就多hash几次，hash还是容易碰撞，那我就扩大数组的范围，使hash值尽可能的均匀分布，减少hash冲突的概率。<br>基于这种思想，BloomFilter诞生了。</li></ol><h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><p>本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。<br>相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><ol><li>多个hash，增大随机性，减少hash碰撞的概率</li><li>扩大数组范围，使hash值均匀分布，进一步减少hash碰撞的概率。</li></ol><h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><p>布隆过滤器是一个 bit 向量或者说 bit 数组。<br>例如：你有10个Url，你完全可以创建一长度是100bit的数组，然后对url分别用5个不同的hash函数进行hash，得到5个hash后的值，这5个值尽可能的保证均匀分布在100个bit的范围内。然后把5个hash值对应的bit位都置为1，判断一个url是否已经存在时，一次看5个bit位是否为1就可以了，如果有任何一个不为1，那么说明这个url不存在。$\color{red}{这里需要注意的是，如果对应的bit位值都为1，那么也不能肯定这个url一定存在，这个是BloomFilter的特点之一。}$<br><img alt="bloomFilter例子" data-src="https://cdn.jsdelivr.net/gh/AemonSwift/AemonSwift@latest/AemonSwift.github.io/images/bloomFilter2.png" class="lozad"></p><h2 id="BloomFilter的实践"><a href="#BloomFilter的实践" class="headerlink" title="BloomFilter的实践"></a>BloomFilter的实践</h2><ol><li>黑名单。比如邮件黑名单过滤器，判断邮件地址是否在黑名单中</li><li>排序(仅限于BitSet)。仔细想想，其实BitSet在set(int value)的时候，“顺便”把value也给排序了。</li><li>网络爬虫。判断某个URL是否已经被爬取过</li><li>K-V系统快速判断某个key是否存在。典型的例子有Hbase，Hbase的每个Region中都包含一个BloomFilter，用于在查询时快速判断某个key在该region中是否存在，如果不存在，直接返回，节省掉后续的查询。</li><li>利用布隆过滤器减少磁盘 IO 或者网络请求，因为一旦一个值必定不存在的话，我们可以不用进行后续昂贵的查询请求。</li></ol><p>既然你使用布隆过滤器来加速查找和判断是否存在，那么性能很低的哈希函数不是个好选择，推荐 MurmurHash、Fnv 这些。</p><h3 id="大Value拆分"><a href="#大Value拆分" class="headerlink" title="大Value拆分"></a>大Value拆分</h3><p>Redis 因其支持 setbit 和 getbit 操作，且纯内存性能高等特点，因此天然就可以作为布隆过滤器来使用。但是布隆过滤器的不当使用极易产生大 Value，增加 Redis 阻塞风险，因此生成环境中建议对体积庞大的布隆过滤器进行拆分。<br>拆分的形式方法多种多样，但是本质是不要将 Hash(Key) 之后的请求分散在多个节点的多个小 bitmap 上，而是应该拆分成多个小 bitmap 之后，对一个 Key 的所有哈希函数都落在这一个小 bitmap 上。</p><h2 id="BloomFilter的准确性——hash函数个数以及bit向量长度的选择问题"><a href="#BloomFilter的准确性——hash函数个数以及bit向量长度的选择问题" class="headerlink" title="BloomFilter的准确性——hash函数个数以及bit向量长度的选择问题"></a>BloomFilter的准确性——hash函数个数以及bit向量长度的选择问题</h2><p>从直观上看，过小的布隆过滤器很快所有的 bit 位均为 1，那么查询任何值都会返回“可能存在”，起不到过滤的目的了。布隆过滤器的长度会直接影响误报率，布隆过滤器越长其误报率越小。<br>另外，哈希函数的个数也需要权衡，个数越多则布隆过滤器 bit 位置位 1 的速度越快，且布隆过滤器的效率越低；但是如果太少的话，那我们的误报率会变高。</p><h2 id="分析hash函数个数以隆过滤器长度的选择指导"><a href="#分析hash函数个数以隆过滤器长度的选择指导" class="headerlink" title="分析hash函数个数以隆过滤器长度的选择指导"></a>分析hash函数个数以隆过滤器长度的选择指导</h2><p>假设：</p><ul><li>k为hash函数个数</li><li>m为布隆过滤器长度</li><li>n插入元素的个数</li><li>p为误报率</li></ul><p>$$m=-\frac{nlnp}{(ln2)^2}$$<br>$$k=\frac{m}{n}ln2$$<br>假设哈希函数以相等的概率选择每个数组位置。如果m是数组长度，则哈希函数未将某个位置置为1的概率为：$1-\frac{1}{m}$。<br>假设k是哈希函数的数量，并且每个散列函数之间没有显着相关性，则该位置未被任何哈希函数设置为1的概率为：$(1-\frac{1}{m})^k$。<br>如果我们插入了n个元素，此位置仍然为0的概率为：$(1-\frac{1}{m})^{kn}$，故为1的概率为：$1-(1-\frac{1}{m})^{kn}$。<br>k个哈希函数都将此位置置为1的概率为：$p=(1-(1-\frac{1}{m})^{kn})^k$。<br>p也就是我们的误差率，我们需要最小化p值。<br>$$p=(1-(1-\frac{1}{m})^{kn})^k\approx (1-e^{\frac{-kn}{m}})^k $$<br>我们先给定m,n的值，求导后得出：<br>$$k=\frac{m}{n}ln2$$<br>再将求出的k值带入p的表达式中，得：<br>$$p=(1-e^{\frac{m}{n}ln2\frac{n}{m}})^{\frac{m}{n}ln2}$$<br>进一步有：<br>$$lnp=-\frac{m}{n}(ln2)^2$$<br>从而得到：<br>$$m=-\frac{nlnp}{(ln2)^2}$$</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="noopener">布隆过滤器</a><br><a href="https://www.jianshu.com/p/2104d11ee0a2" target="_blank" rel="noopener">详解布隆过滤器的原理、使用场景和注意事</a><br><a href="http://blog.lanjingdejia.com/articles/2018/07/13/1531479344453.html" target="_blank" rel="noopener">那些惊艳的算法们（一）——布隆过滤器</a><br><a href="https://blog.csdn.net/chdhust/article/details/48576961" target="_blank" rel="noopener">bloom filter与Cuckoo Filter</a><br><a href="https://blog.csdn.net/qq_17305249/article/details/94996252" target="_blank" rel="noopener">布谷鸟过滤器</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;假设你现在要处理这样一个问题，你有一个网站并且拥有很多访客，每当有用户访问时，你想知道这个ip是不是第一次访问你的网站。这是一个很常见的场景
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>人生bug之地</title>
    <link href="http://aemonswift.github.io/2019/10/29/%E4%BA%BA%E7%94%9Fbug%E4%B9%8B%E5%9C%B0/"/>
    <id>http://aemonswift.github.io/2019/10/29/人生bug之地/</id>
    <published>2019-10-29T00:23:09.000Z</published>
    <updated>2019-10-29T06:48:23.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="bug引入时间"><a href="#bug引入时间" class="headerlink" title="bug引入时间"></a>bug引入时间</h1><p>2019年10月27日，毕业半年多，第一次写了人生第一个bug。由于修改了别人的代码：其它服务调用此接口时会发生记录信息丢失问题，以致于线上出现了部分属性信息丢失原因。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dao)</span> <span class="title">UpdateChannelInfo</span><span class="params">(ctx context.Context, req *v1.UpdateChannelInfoReq)</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">_updateChannelInfo = <span class="string">"update channel set  "</span></span><br><span class="line">field              []<span class="keyword">string</span></span><br><span class="line">args               []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> req.Name != <span class="string">""</span> &#123;</span><br><span class="line">field = <span class="built_in">append</span>(field, <span class="string">"name=? "</span>)</span><br><span class="line">args = <span class="built_in">append</span>(args, req.Name)</span><br><span class="line">&#125;</span><br><span class="line">field = <span class="built_in">append</span>(field, <span class="string">" Background=?"</span>) <span class="comment">//引入bug，去掉了Background不为""的判断</span></span><br><span class="line">args = <span class="built_in">append</span>(args, req.Background)</span><br><span class="line"><span class="keyword">if</span> req.Latest != <span class="number">0</span> &#123;</span><br><span class="line">field = <span class="built_in">append</span>(field, <span class="string">" latest=? "</span>)</span><br><span class="line">args = <span class="built_in">append</span>(args, req.Latest)</span><br><span class="line">&#125;</span><br><span class="line">field = <span class="built_in">append</span>(field, <span class="string">" alpha=?"</span>)</span><br><span class="line">args = <span class="built_in">append</span>(args, req.Alpha)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">args = <span class="built_in">append</span>(args, req.Cid)</span><br><span class="line">res, err := d.db.Exec(ctx, _updateChannelInfo+strings.Join(field, <span class="string">","</span>)+<span class="string">" where cid=? ;"</span>, args...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Error(<span class="string">"d.db.Exec() error(%v)"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res.LastInsertId()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="bug的原因"><a href="#bug的原因" class="headerlink" title="bug的原因"></a>bug的原因</h1><p>此接口调用未考虑到有一方调用——只修改Latest属性是另外一个服务来调用；其它属性的修改又是一个服务来调用。由于自己的疏忽，未考虑到此接口供多方服务来进行调用——只修改Latest属性的调用把Background和alpha都置为0.</p><h2 id="潜在的bug"><a href="#潜在的bug" class="headerlink" title="潜在的bug"></a>潜在的bug</h2><p>若对入参数进行这样设置：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">message UpdateChannelInfoReq &#123;</span><br><span class="line">    <span class="keyword">int64</span> cid = <span class="number">1</span> [(gogoproto.moretags) = <span class="string">"form:\"cid\" validate:\"required,min=1\""</span>];</span><br><span class="line"><span class="keyword">string</span> name = <span class="number">2</span> [(gogoproto.moretags) = <span class="string">"form:\"name\""</span>];</span><br><span class="line">    <span class="keyword">string</span> icon = <span class="number">3</span> [(gogoproto.moretags) = <span class="string">"form:\"icon\""</span>];</span><br><span class="line">    <span class="keyword">string</span> color = <span class="number">4</span> [(gogoproto.moretags) = <span class="string">"form:\"color\""</span>];</span><br><span class="line">    <span class="keyword">string</span> background = <span class="number">5</span> [(gogoproto.moretags) = <span class="string">"form:\"background\""</span>];</span><br><span class="line"><span class="keyword">int64</span> latest = <span class="number">6</span> [(gogoproto.jsontag) = <span class="string">"latest"</span>, (gogoproto.casttype) = <span class="string">"go-common/library/time.Time"</span>];</span><br><span class="line">    <span class="keyword">int32</span> alpha=<span class="number">7</span> [(gogoproto.moretags) = <span class="string">"form:\"alpha\" validate=\"gt=0\""</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现如下问题：有一方服务想修改Latest属性，会一直发生请求错误。因为：alpha参数属性是必须大于0的。特别是job服务很难进行排查。</p><h1 id="如何避免类似问题"><a href="#如何避免类似问题" class="headerlink" title="如何避免类似问题"></a>如何避免类似问题</h1><ol><li>设计写接口的时候，尽量做到功能单一，且做到一个写接口只给一个服务方来调用。例如：上面只修改属性可以拆成一个接口；其它属性修改拆成另外一个接口。</li><li>测试要认真：一定要从线上，预发，以及线上灰度上面认真测试，特别是修改别人代码的接口（修改一行也要测），以及关注mysql的qps（防止接口中写入慢查询），日志的错误信息（防止请求错误过多，例如上述的参数校验导致了更新Latest属性的接口一直请求错误）。</li><li>数据库里面的数据一定要进行每日备份，错误怎么避免都会犯错的，但最坏打算就是恢复数据。</li></ol><p>测试修改别人代码的接口时候，一定要先把之前记录copy出来，然后进行修改，进行对比，特别是线上更需要进行对比（经过大约三四个小时，再去对比几次）。通过app查看和表来查看。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;bug引入时间&quot;&gt;&lt;a href=&quot;#bug引入时间&quot; class=&quot;headerlink&quot; title=&quot;bug引入时间&quot;&gt;&lt;/a&gt;bug引入时间&lt;/h1&gt;&lt;p&gt;2019年10月27日，毕业半年多，第一次写了人生第一个bug。由于修改了别人的代码：其它服务调用此
      
    
    </summary>
    
    
      <category term="缺陷" scheme="http://aemonswift.github.io/categories/%E7%BC%BA%E9%99%B7/"/>
    
      <category term="工作错误" scheme="http://aemonswift.github.io/categories/%E7%BC%BA%E9%99%B7/%E5%B7%A5%E4%BD%9C%E9%94%99%E8%AF%AF/"/>
    
    
      <category term="缺陷" scheme="http://aemonswift.github.io/tags/%E7%BC%BA%E9%99%B7/"/>
    
  </entry>
  
  <entry>
    <title>常见限流算法</title>
    <link href="http://aemonswift.github.io/2019/10/28/%E5%B8%B8%E8%A7%81%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/"/>
    <id>http://aemonswift.github.io/2019/10/28/常见限流算法/</id>
    <published>2019-10-28T05:19:27.000Z</published>
    <updated>2019-10-28T11:37:41.703Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么需要限流算法"><a href="#为什么需要限流算法" class="headerlink" title="为什么需要限流算法"></a>为什么需要限流算法</h1><p>在高并发系统中，保护系统三大利器：缓存，降级，限流，即主要降低数据库的访问。当请求量超过系统负载的时候，为了保证系统正常运行，当请求达到一定的并发数或速率，就需要进行等待、排队、降级、拒绝服务等，从而保证了有效系统正常运行。<br>按照服务调用方分为如下几种类型</p><ol><li>与用户打交道服务</li></ol><p>这类服务导致系统负载过高原因：</p><ul><li>用户增长过快（好事）</li><li>某个热点事件（微博热搜）</li><li>竞争对象爬虫</li><li>恶意刷单</li></ul><p>这类系统都是无法预知的，即弹性扩容根本不可能实现。</p><ol start="2"><li>对内的RPC服务<br>一个服务A的接口可能被B，C，D，E多个服务进行调用，在B服务发生突发流量时，直接把A服务给调用挂了，导致A服务对C，D，E也无法提供服务。解决方案如下：a.每个调用方采用线程池进行资源隔离；b.使用限流手段对每个调用方进行限流。</li></ol><h1 id="常见的限流算法"><a href="#常见的限流算法" class="headerlink" title="常见的限流算法"></a>常见的限流算法</h1><p>计数器，令牌桶，漏桶，窗口等</p><h2 id="计数器限流"><a href="#计数器限流" class="headerlink" title="计数器限流"></a>计数器限流</h2><p>主要用来限制总并发数，比如数据库连接池大小、线程池大小、程序访问并发数等都是使用计数器算法。</p><h3 id="计数器限流示例——通过限制系统的并发调用程度来限流"><a href="#计数器限流示例——通过限制系统的并发调用程度来限流" class="headerlink" title="计数器限流示例——通过限制系统的并发调用程度来限流"></a>计数器限流示例——通过限制系统的并发调用程度来限流</h3><p>例如go官方包里面httpServer频率限制，基本思路就是为连接数计数，通过make chan来建立一个最大连接数的channel, 每次accept就+1，close时候就-1. 当到达最大连接数时，就等待空闲连接出来之后再accept。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> netutil <span class="comment">// import "golang.org/x/net/netutil"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> limitListener <span class="keyword">struct</span> &#123;</span><br><span class="line">net.Listener</span><br><span class="line">sem       <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">closeOnce sync.Once     <span class="comment">// ensures the done chan is only closed once</span></span><br><span class="line">done      <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// no values sent; closed when Close is called</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> limitListenerConn <span class="keyword">struct</span> &#123;</span><br><span class="line">net.Conn</span><br><span class="line">releaseOnce sync.Once</span><br><span class="line">release     <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">// <span class="title">LimitListener</span> <span class="title">returns</span> <span class="title">a</span> <span class="title">Listener</span> <span class="title">that</span> <span class="title">accepts</span> <span class="title">at</span> <span class="title">most</span> <span class="title">n</span> <span class="title">simultaneous</span></span></span><br><span class="line"><span class="function">// <span class="title">connections</span> <span class="title">from</span> <span class="title">the</span> <span class="title">provided</span> <span class="title">Listener</span>.</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">LimitListener</span><span class="params">(l net.Listener, n <span class="keyword">int</span>)</span> <span class="title">net</span>.<span class="title">Listener</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;limitListener&#123;</span><br><span class="line">Listener: l,</span><br><span class="line">sem:      <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, n),</span><br><span class="line">done:     <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// acquire acquires the limiting semaphore. Returns true if successfully</span></span><br><span class="line"><span class="comment">// accquired, false if the listener is closed and the semaphore is not</span></span><br><span class="line"><span class="comment">// acquired.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *limitListener)</span> <span class="title">acquire</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-l.done:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">case</span> l.sem &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *limitListener)</span> <span class="title">release</span><span class="params">()</span></span> &#123; &lt;-l.sem &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *limitListener)</span> <span class="title">Accept</span><span class="params">()</span> <span class="params">(net.Conn, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//如果sem满了，就会阻塞在这</span></span><br><span class="line">acquired := l.acquire()</span><br><span class="line"><span class="comment">// If the semaphore isn't acquired because the listener was closed, expect</span></span><br><span class="line"><span class="comment">// that this call to accept won't block, but immediately return an error.</span></span><br><span class="line">c, err := l.Listener.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> acquired &#123;</span><br><span class="line">l.release()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;limitListenerConn&#123;Conn: c, release: l.release&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *limitListener)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">err := l.Listener.Close()</span><br><span class="line">l.closeOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="built_in">close</span>(l.done) &#125;)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *limitListenerConn)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">err := l.Conn.Close()</span><br><span class="line">    <span class="comment">//close时释放占用的sem</span></span><br><span class="line">l.releaseOnce.Do(l.release)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单元测试</span></span><br><span class="line"><span class="keyword">package</span> netutil</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"sync/atomic"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"golang.org/x/net/internal/nettest"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLimitListener</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> max = <span class="number">5</span></span><br><span class="line">attempts := (nettest.MaxOpenFiles() - max) / <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> attempts &gt; <span class="number">256</span> &#123; <span class="comment">// maximum length of accept queue is 128 by default</span></span><br><span class="line">attempts = <span class="number">256</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">l, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:0"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">t.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> l.Close()</span><br><span class="line">l = LimitListener(l, max)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> open <span class="keyword">int32</span></span><br><span class="line"><span class="keyword">go</span> http.Serve(l, http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> n := atomic.AddInt32(&amp;open, <span class="number">1</span>); n &gt; max &#123;</span><br><span class="line">t.Errorf(<span class="string">"%d open connections, want &lt;= %d"</span>, n, max)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> atomic.AddInt32(&amp;open, <span class="number">-1</span>)</span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">fmt.Fprint(w, <span class="string">"some body"</span>)</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> failed <span class="keyword">int32</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; attempts; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">c := http.Client&#123;Timeout: <span class="number">3</span> * time.Second&#125;</span><br><span class="line">r, err := c.Get(<span class="string">"http://"</span> + l.Addr().String())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">t.Log(err)</span><br><span class="line">atomic.AddInt32(&amp;failed, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> r.Body.Close()</span><br><span class="line">io.Copy(ioutil.Discard, r.Body)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line"><span class="comment">// We expect some Gets to fail as the kernel's accept queue is filled,</span></span><br><span class="line"><span class="comment">// but most should succeed.</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">int</span>(failed) &gt;= attempts/<span class="number">2</span> &#123;</span><br><span class="line">t.Errorf(<span class="string">"%d requests failed within %d attempts"</span>, failed, attempts)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用count进行统计当前正在并发执行的次数，如果超过域值就简单粗暴的直接响应给用户，说明系统繁忙，请稍后再试或其它跟业务相关的信息。<br>$\color{red}{弊端：}$使用count简单粗暴超过域值就拒绝请求，可能只是瞬时的请求量高，也会拒绝请求。</p><h3 id="计数器限流示例2——通过限制单位时间段内调用量来限流"><a href="#计数器限流示例2——通过限制单位时间段内调用量来限流" class="headerlink" title="计数器限流示例2——通过限制单位时间段内调用量来限流"></a>计数器限流示例2——通过限制单位时间段内调用量来限流</h3><p>上述方法简单粗暴，一般我们会限制一秒钟的能够通过的请求数，比如限流qps为100，算法的实现思路就是从第一个请求进来开始计时，在接下去的1s内，每来一个请求，就把计数加1，如果累加的数字达到了100，那么后续的请求就会被全部拒绝。等到1s结束后，把计数恢复成0，重新开始计数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AbandonReqLimitService <span class="keyword">struct</span> &#123;</span><br><span class="line">    Interval time.Duration <span class="comment">// 设置计数器的时间间隔</span></span><br><span class="line">    MaxCount <span class="keyword">int</span> <span class="comment">// 计数器的最大值</span></span><br><span class="line">    Lock     sync.Mutex <span class="comment">// 锁</span></span><br><span class="line">    ReqCount <span class="keyword">int</span> <span class="comment">// 计数器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateAbandonReqLimitService</span><span class="params">(interval time.Duration, maxCount <span class="keyword">int</span>)</span> *<span class="title">AbandonReqLimitService</span></span> &#123;</span><br><span class="line">    reqLimit := &amp;AbandonReqLimitService&#123;</span><br><span class="line">        Interval: interval,</span><br><span class="line">        MaxCount: maxCount,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// 开启一个go协程来定时更新计数器</span></span><br><span class="line">        ticker := time.NewTicker(interval) <span class="comment">// go中的定时器</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            &lt;-ticker.C</span><br><span class="line">            reqLimit.Lock.Lock()</span><br><span class="line">            reqLimit.ReqCount = <span class="number">0</span></span><br><span class="line">            reqLimit.Lock.Unlock()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> reqLimit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(reqLimit *AbandonReqLimitService)</span> <span class="title">GetTokenAbandonRequest</span><span class="params">()</span> <span class="title">bool</span></span> &#123; <span class="comment">// 取令牌函数</span></span><br><span class="line">    reqLimit.Lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> reqLimit.Lock.Unlock()</span><br><span class="line">    <span class="keyword">if</span> reqLimit.ReqCount &lt; reqLimit.MaxCount &#123;</span><br><span class="line">        reqLimit.ReqCount += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$\color{red}{弊端：}$如果我在单位时间1s内的前10ms，已经通过了100个请求，那后面的990ms，只能请求拒绝，我们把这种现象称为“突刺现象”.</p><h3 id="计数器限流示例3——采用队列的形式"><a href="#计数器限流示例3——采用队列的形式" class="headerlink" title="计数器限流示例3——采用队列的形式"></a>计数器限流示例3——采用队列的形式</h3><p>形式类似信号量Semaphore。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SemaphoreService <span class="keyword">struct</span> &#123;</span><br><span class="line">Semaphore <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateSemaphore</span><span class="params">(maxCnt <span class="keyword">int</span>)</span> <span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125;&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;,maxCnt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(semaphore *SemaphoreService)</span><span class="title">Accquire</span><span class="params">()</span></span>&#123;</span><br><span class="line">semaphore.Semaphore&lt;-<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(semaphore *SemaphoreService)</span> <span class="title">Release</span><span class="params">()</span></span>&#123;</span><br><span class="line">&lt;-semaphore.Semaphore</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是瞬时的高并发，可以使请求在阻塞队列中排队，而不是马上拒绝请求，从而达到一个流量削峰的目的。$\color{red}{但无法应对短时间的突发流量。}</p><h2 id="漏桶限流"><a href="#漏桶限流" class="headerlink" title="漏桶限流"></a>漏桶限流</h2><p>为了消除”突刺现象”，可以采用漏桶算法实现限流，漏桶算法这个名字就很形象，算法内部有一个容器，类似生活用到的漏斗，当请求进来时，相当于水倒入漏斗，然后从下端小口慢慢匀速的流出。不管上面流量多大，下面流出的速度始终保持不变。<br>漏桶算法(Leaky Bucket)是网络世界中流量整形（Traffic Shaping）或速率限制（Rate Limiting）时经常使用的一种算法，它的主要目的是控制数据注入到网络的速率，平滑网络上的突发流量。<br>不管服务调用方多么不稳定，通过漏桶算法进行限流，每10毫秒处理一次请求。因为处理的速度是固定的，请求进来的速度是未知的，可能突然进来很多请求，没来得及处理的请求就先放在桶里，既然是个桶，肯定是有容量上限，如果桶满了，那么新进来的请求就丢弃。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ratelimiter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> rateLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">lck      *sync.Mutex</span><br><span class="line">rate     <span class="keyword">float64</span>   <span class="comment">//最大速率限制</span></span><br><span class="line">balance  <span class="keyword">float64</span>   <span class="comment">//漏桶的余量</span></span><br><span class="line">limit    <span class="keyword">float64</span>   <span class="comment">//漏桶的最大容量限制</span></span><br><span class="line">lastTime time.Time <span class="comment">//上次检查的时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRateLimiter</span><span class="params">(limitPerSecond <span class="keyword">int</span>, balance <span class="keyword">int</span>)</span> *<span class="title">rateLimiter</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;rateLimiter&#123;</span><br><span class="line">lck:      <span class="built_in">new</span>(sync.Mutex),</span><br><span class="line">rate:     <span class="keyword">float64</span>(limitPerSecond),</span><br><span class="line">balance:  <span class="keyword">float64</span>(balance),</span><br><span class="line">limit:    <span class="keyword">float64</span>(balance),</span><br><span class="line">lastTime: time.Now(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *rateLimiter)</span> <span class="title">Check</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">ok := <span class="literal">false</span></span><br><span class="line">r.lck.Lock()</span><br><span class="line">now := time.Now()</span><br><span class="line">dur := now.Sub(r.lastTime).Seconds()</span><br><span class="line">r.lastTime = now</span><br><span class="line">water := dur * r.rate <span class="comment">//计算这段时间内漏桶流出水的流量water</span></span><br><span class="line">r.balance += water    <span class="comment">//漏桶流出water容量的水，自然漏桶的余量多出water</span></span><br><span class="line"><span class="keyword">if</span> r.balance &gt; r.limit &#123;</span><br><span class="line">r.balance = r.limit</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> r.balance &gt;= <span class="number">1</span> &#123; <span class="comment">//漏桶余量足够容下当前的请求</span></span><br><span class="line">r.balance -= <span class="number">1</span></span><br><span class="line">ok = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">r.lck.Unlock()</span><br><span class="line"><span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单元测试</span></span><br><span class="line"><span class="keyword">package</span> ratelimiter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestRateLimiter_Check</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">limiter := NewRateLimiter(<span class="number">10</span>, <span class="number">1</span>)</span><br><span class="line">start := time.Now()</span><br><span class="line">count := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1e3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> limiter.Check() &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">count++</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"count:"</span>, count)</span><br><span class="line">fmt.Println(time.Now().Sub(start).Seconds())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>漏桶算法能够强行限制数据的传输速率，$\color{blue}{但无法应对短时间的突发流量}$。</p><h2 id="令牌桶限流"><a href="#令牌桶限流" class="headerlink" title="令牌桶限流"></a>令牌桶限流</h2><p>从某种意义上讲，令牌桶算法是对漏桶算法的一种改进，桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用。<br>令牌桶算法（Token Bucket）：是网络流量整形（Traffic Shaping）和速率限制（Rate Limiting）中最常使用的一种算法。典型情况下，令牌桶算法用来控制发送到网络上的数据的数目，并允许突发数据的发送。<br>在令牌桶算法中，存在一个桶，用来存放固定数量的令牌。算法中存在一种机制，以一定的速率往桶中放令牌。每次请求调用需要先获取令牌，只有拿到令牌，才有机会继续执行，否则选择选择等待可用的令牌、或者直接拒绝。<br>放令牌这个动作是持续不断的进行，如果桶中令牌数达到上限，就丢弃令牌，所以就存在这种情况，桶中一直有大量的可用令牌，这时进来的请求就可以直接拿到令牌执行，比如设置qps为100，那么限流器初始化完成一秒后，桶中就已经有100个令牌了，这时服务还没完全启动好，等启动完成对外提供服务时，该限流器可以抵挡瞬时的100个请求。所以，只有桶中没有令牌时，请求才会进行等待，最后相当于以一定的速率执行。<br>一个简单的实现：利用的就是channel的阻塞操作。<br>我们把一个指定尺寸channel，相当于一个指定容量的令牌桶，每一个空闲位置就是一个令牌。由于channel满时就无法向其中加元素，所以我们就可以以固定的速率消费channel中的消息（释放空间相当于添加令牌），取令牌就是添加一条消息，当令牌桶满时就无法正常添加消息（取令牌）了，这样就利用channel来构造了一个限流器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NotAbandonReqLimitService <span class="keyword">struct</span> &#123;</span><br><span class="line">    TokenPool <span class="keyword">chan</span> <span class="keyword">bool</span> <span class="comment">// 令牌桶</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateNewRequestLimitService</span><span class="params">(interval time.Duration, maxCnt <span class="keyword">int</span>)</span> *<span class="title">NotAbandonReqLimitService</span></span> &#123;</span><br><span class="line">    reqLimit := &amp;NotAbandonReqLimitService&#123;&#125;</span><br><span class="line">    reqLimit.TokenPool = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, maxCnt) <span class="comment">// 令牌桶最大容量</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        tmpStr := strconv.Itoa(maxCnt)</span><br><span class="line">        maxCntInt64,_ := strconv.ParseInt(tmpStr, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">        ticker := time.NewTicker( time.Duration(interval.Nanoseconds()/(maxCntInt64*<span class="number">1000</span>*<span class="number">1000</span>))* time.Millisecond) <span class="comment">// 匀速添加令牌，1s/最大qps 就是添加的速率</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            &lt;- ticker.C</span><br><span class="line">            &lt;- reqLimit.TokenPool</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> reqLimit</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(reqLimit *NotAbandonReqLimitService)</span> <span class="title">GetTokenNotAbandonRequest</span><span class="params">()</span></span> &#123;</span><br><span class="line">    reqLimit.TokenPool &lt;- <span class="literal">true</span> <span class="comment">// 消费令牌</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如go官方包rate，其思想为：用户配置的平均发送速率为r，则每隔1/r秒一个令牌被加入到桶中（每秒会有r个令牌放入桶中），桶中最多可以存放b个令牌。如果令牌到达时令牌桶已经满了，那么这个令牌会被丢弃；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rate</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"> </span><br><span class="line"><span class="string">"golang.org/x/net/context"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Limit defines the maximum frequency of some events.</span></span><br><span class="line"><span class="comment">// Limit is represented as number of events per second.</span></span><br><span class="line"><span class="comment">// A zero Limit allows no events.</span></span><br><span class="line"><span class="keyword">type</span> Limit <span class="keyword">float64</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Inf is the infinite rate limit; it allows all events (even if burst is zero).</span></span><br><span class="line"><span class="keyword">const</span> Inf = Limit(math.MaxFloat64)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Every converts a minimum time interval between events to a Limit.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Every</span><span class="params">(interval time.Duration)</span> <span class="title">Limit</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> interval &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Inf</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> / Limit(interval.Seconds())</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// A Limiter controls how frequently events are allowed to happen.</span></span><br><span class="line"><span class="comment">// It implements a "token bucket" of size b, initially full and refilled</span></span><br><span class="line"><span class="comment">// at rate r tokens per second.</span></span><br><span class="line"><span class="comment">// Informally, in any large enough time interval, the Limiter limits the</span></span><br><span class="line"><span class="comment">// rate to r tokens per second, with a maximum burst size of b events.</span></span><br><span class="line"><span class="comment">// As a special case, if r == Inf (the infinite rate), b is ignored.</span></span><br><span class="line"><span class="comment">// See https://en.wikipedia.org/wiki/Token_bucket for more about token buckets.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The zero value is a valid Limiter, but it will reject all events.</span></span><br><span class="line"><span class="comment">// Use NewLimiter to create non-zero Limiters.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Limiter has three main methods, Allow, Reserve, and Wait.</span></span><br><span class="line"><span class="comment">// Most callers should use Wait.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Each of the three methods consumes a single token.</span></span><br><span class="line"><span class="comment">// They differ in their behavior when no token is available.</span></span><br><span class="line"><span class="comment">// If no token is available, Allow returns false.</span></span><br><span class="line"><span class="comment">// If no token is available, Reserve returns a reservation for a future token</span></span><br><span class="line"><span class="comment">// and the amount of time the caller must wait before using it.</span></span><br><span class="line"><span class="comment">// If no token is available, Wait blocks until one can be obtained</span></span><br><span class="line"><span class="comment">// or its associated context.Context is canceled.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The methods AllowN, ReserveN, and WaitN consume n tokens.</span></span><br><span class="line"><span class="keyword">type</span> Limiter <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//maximum token, token num per second</span></span><br><span class="line">limit Limit</span><br><span class="line"><span class="comment">//burst field, max token num</span></span><br><span class="line">burst <span class="keyword">int</span></span><br><span class="line">mu    sync.Mutex</span><br><span class="line"><span class="comment">//tokens num, change</span></span><br><span class="line">tokens <span class="keyword">float64</span></span><br><span class="line"><span class="comment">// last is the last time the limiter's tokens field was updated</span></span><br><span class="line">last time.Time</span><br><span class="line"><span class="comment">// lastEvent is the latest time of a rate-limited event (past or future)</span></span><br><span class="line">lastEvent time.Time</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Limit returns the maximum overall event rate.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span> <span class="title">Limit</span><span class="params">()</span> <span class="title">Limit</span></span> &#123;</span><br><span class="line">lim.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> lim.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> lim.limit</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Burst returns the maximum burst size. Burst is the maximum number of tokens</span></span><br><span class="line"><span class="comment">// that can be consumed in a single call to Allow, Reserve, or Wait, so higher</span></span><br><span class="line"><span class="comment">// Burst values allow more events to happen at once.</span></span><br><span class="line"><span class="comment">// A zero Burst allows no events, unless limit == Inf.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span> <span class="title">Burst</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> lim.burst</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// NewLimiter returns a new Limiter that allows events up to rate r and permits</span></span><br><span class="line"><span class="comment">// bursts of at most b tokens.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLimiter</span><span class="params">(r Limit, b <span class="keyword">int</span>)</span> *<span class="title">Limiter</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Limiter&#123;</span><br><span class="line">limit: r,</span><br><span class="line">burst: b,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Allow is shorthand for AllowN(time.Now(), 1).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span> <span class="title">Allow</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> lim.AllowN(time.Now(), <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// AllowN reports whether n events may happen at time now.</span></span><br><span class="line"><span class="comment">// Use this method if you intend to drop / skip events that exceed the rate limit.</span></span><br><span class="line"><span class="comment">// Otherwise use Reserve or Wait.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span> <span class="title">AllowN</span><span class="params">(now time.Time, n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> lim.reserveN(now, n, <span class="number">0</span>).ok</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// A Reservation holds information about events that are permitted by a Limiter to happen after a delay.</span></span><br><span class="line"><span class="comment">// A Reservation may be canceled, which may enable the Limiter to permit additional events.</span></span><br><span class="line"><span class="keyword">type</span> Reservation <span class="keyword">struct</span> &#123;</span><br><span class="line">ok     <span class="keyword">bool</span></span><br><span class="line">lim    *Limiter</span><br><span class="line">tokens <span class="keyword">int</span></span><br><span class="line"><span class="comment">//This is the time to action</span></span><br><span class="line">timeToAct time.Time</span><br><span class="line"><span class="comment">// This is the Limit at reservation time, it can change later.</span></span><br><span class="line">limit Limit</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// OK returns whether the limiter can provide the requested number of tokens</span></span><br><span class="line"><span class="comment">// within the maximum wait time.  If OK is false, Delay returns InfDuration, and</span></span><br><span class="line"><span class="comment">// Cancel does nothing.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reservation)</span> <span class="title">OK</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.ok</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Delay is shorthand for DelayFrom(time.Now()).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reservation)</span> <span class="title">Delay</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.DelayFrom(time.Now())</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// InfDuration is the duration returned by Delay when a Reservation is not OK.</span></span><br><span class="line"><span class="keyword">const</span> InfDuration = time.Duration(<span class="number">1</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// DelayFrom returns the duration for which the reservation holder must wait</span></span><br><span class="line"><span class="comment">// before taking the reserved action.  Zero duration means act immediately.</span></span><br><span class="line"><span class="comment">// InfDuration means the limiter cannot grant the tokens requested in this</span></span><br><span class="line"><span class="comment">// Reservation within the maximum wait time.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reservation)</span> <span class="title">DelayFrom</span><span class="params">(now time.Time)</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !r.ok &#123;</span><br><span class="line"><span class="keyword">return</span> InfDuration</span><br><span class="line">&#125;</span><br><span class="line">delay := r.timeToAct.Sub(now)</span><br><span class="line"><span class="keyword">if</span> delay &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> delay</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Cancel is shorthand for CancelAt(time.Now()).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reservation)</span> <span class="title">Cancel</span><span class="params">()</span></span> &#123;</span><br><span class="line">r.CancelAt(time.Now())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// CancelAt indicates that the reservation holder will not perform the reserved action</span></span><br><span class="line"><span class="comment">// and reverses the effects of this Reservation on the rate limit as much as possible,</span></span><br><span class="line"><span class="comment">// considering that other reservations may have already been made.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reservation)</span> <span class="title">CancelAt</span><span class="params">(now time.Time)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !r.ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">r.lim.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> r.lim.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> r.lim.limit == Inf || r.tokens == <span class="number">0</span> || r.timeToAct.Before(now) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// calculate tokens to restore</span></span><br><span class="line"><span class="comment">// The duration between lim.lastEvent and r.timeToAct tells us how many tokens were reserved</span></span><br><span class="line"><span class="comment">// after r was obtained. These tokens should not be restored.</span></span><br><span class="line">restoreTokens := <span class="keyword">float64</span>(r.tokens) - r.limit.tokensFromDuration(r.lim.lastEvent.Sub(r.timeToAct))</span><br><span class="line"><span class="keyword">if</span> restoreTokens &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// advance time to now</span></span><br><span class="line">now, _, tokens := r.lim.advance(now)</span><br><span class="line"><span class="comment">// calculate new number of tokens</span></span><br><span class="line">tokens += restoreTokens</span><br><span class="line"><span class="keyword">if</span> burst := <span class="keyword">float64</span>(r.lim.burst); tokens &gt; burst &#123;</span><br><span class="line">tokens = burst</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// update state</span></span><br><span class="line">r.lim.last = now</span><br><span class="line">r.lim.tokens = tokens</span><br><span class="line"><span class="keyword">if</span> r.timeToAct == r.lim.lastEvent &#123;</span><br><span class="line">prevEvent := r.timeToAct.Add(r.limit.durationFromTokens(<span class="keyword">float64</span>(-r.tokens)))</span><br><span class="line"><span class="keyword">if</span> !prevEvent.Before(now) &#123;</span><br><span class="line">r.lim.lastEvent = prevEvent</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Reserve is shorthand for ReserveN(time.Now(), 1).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span> <span class="title">Reserve</span><span class="params">()</span> *<span class="title">Reservation</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> lim.ReserveN(time.Now(), <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ReserveN returns a Reservation that indicates how long the caller must wait before n events happen.</span></span><br><span class="line"><span class="comment">// The Limiter takes this Reservation into account when allowing future events.</span></span><br><span class="line"><span class="comment">// ReserveN returns false if n exceeds the Limiter's burst size.</span></span><br><span class="line"><span class="comment">// Usage example:</span></span><br><span class="line"><span class="comment">//   r, ok := lim.ReserveN(time.Now(), 1)</span></span><br><span class="line"><span class="comment">//   if !ok &#123;</span></span><br><span class="line"><span class="comment">//     // Not allowed to act! Did you remember to set lim.burst to be &gt; 0 ?</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">//   time.Sleep(r.Delay())</span></span><br><span class="line"><span class="comment">//   Act()</span></span><br><span class="line"><span class="comment">// Use this method if you wish to wait and slow down in accordance with the rate limit without dropping events.</span></span><br><span class="line"><span class="comment">// If you need to respect a deadline or cancel the delay, use Wait instead.</span></span><br><span class="line"><span class="comment">// To drop or skip events exceeding rate limit, use Allow instead.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span> <span class="title">ReserveN</span><span class="params">(now time.Time, n <span class="keyword">int</span>)</span> *<span class="title">Reservation</span></span> &#123;</span><br><span class="line">r := lim.reserveN(now, n, InfDuration)</span><br><span class="line"><span class="keyword">return</span> &amp;r</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Wait is shorthand for WaitN(ctx, 1).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span> <span class="title">Wait</span><span class="params">(ctx context.Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> lim.WaitN(ctx, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// WaitN blocks until lim permits n events to happen.</span></span><br><span class="line"><span class="comment">// It returns an error if n exceeds the Limiter's burst size, the Context is</span></span><br><span class="line"><span class="comment">// canceled, or the expected wait time exceeds the Context's Deadline.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span> <span class="title">WaitN</span><span class="params">(ctx context.Context, n <span class="keyword">int</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> n &gt; lim.burst &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"rate: Wait(n=%d) exceeds limiter's burst %d"</span>, n, lim.burst)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Check if ctx is already cancelled</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span> ctx.Err()</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Determine wait limit</span></span><br><span class="line">now := time.Now()</span><br><span class="line">waitLimit := InfDuration</span><br><span class="line"><span class="keyword">if</span> deadline, ok := ctx.Deadline(); ok &#123;</span><br><span class="line">waitLimit = deadline.Sub(now)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Reserve</span></span><br><span class="line">r := lim.reserveN(now, n, waitLimit)</span><br><span class="line"><span class="keyword">if</span> !r.ok &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"rate: Wait(n=%d) would exceed context deadline"</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Wait</span></span><br><span class="line">t := time.NewTimer(r.DelayFrom(now))</span><br><span class="line"><span class="keyword">defer</span> t.Stop()</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-t.C:</span><br><span class="line"><span class="comment">// We can proceed.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="comment">// Context was canceled before we could proceed.  Cancel the</span></span><br><span class="line"><span class="comment">// reservation, which may permit other events to proceed sooner.</span></span><br><span class="line">r.Cancel()</span><br><span class="line"><span class="keyword">return</span> ctx.Err()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// SetLimit is shorthand for SetLimitAt(time.Now(), newLimit).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span> <span class="title">SetLimit</span><span class="params">(newLimit Limit)</span></span> &#123;</span><br><span class="line">lim.SetLimitAt(time.Now(), newLimit)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// SetLimitAt sets a new Limit for the limiter. The new Limit, and Burst, may be violated</span></span><br><span class="line"><span class="comment">// or underutilized by those which reserved (using Reserve or Wait) but did not yet act</span></span><br><span class="line"><span class="comment">// before SetLimitAt was called.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span> <span class="title">SetLimitAt</span><span class="params">(now time.Time, newLimit Limit)</span></span> &#123;</span><br><span class="line">lim.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> lim.mu.Unlock()</span><br><span class="line">now, _, tokens := lim.advance(now)</span><br><span class="line">lim.last = now</span><br><span class="line">lim.tokens = tokens</span><br><span class="line">lim.limit = newLimit</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// reserveN is a helper method for AllowN, ReserveN, and WaitN.</span></span><br><span class="line"><span class="comment">// maxFutureReserve specifies the maximum reservation wait duration allowed.</span></span><br><span class="line"><span class="comment">// reserveN returns Reservation, not *Reservation, to avoid allocation in AllowN and WaitN.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span> <span class="title">reserveN</span><span class="params">(now time.Time, n <span class="keyword">int</span>, maxFutureReserve time.Duration)</span> <span class="title">Reservation</span></span> &#123;</span><br><span class="line">lim.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> lim.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> lim.limit == Inf &#123;</span><br><span class="line"><span class="keyword">return</span> Reservation&#123;</span><br><span class="line">ok:        <span class="literal">true</span>,</span><br><span class="line">lim:       lim,</span><br><span class="line">tokens:    n,</span><br><span class="line">timeToAct: now,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">now, last, tokens := lim.advance(now)</span><br><span class="line"><span class="comment">// Calculate the remaining number of tokens resulting from the request.</span></span><br><span class="line">tokens -= <span class="keyword">float64</span>(n)</span><br><span class="line"><span class="comment">// Calculate the wait duration</span></span><br><span class="line"><span class="keyword">var</span> waitDuration time.Duration</span><br><span class="line"><span class="keyword">if</span> tokens &lt; <span class="number">0</span> &#123;</span><br><span class="line">waitDuration = lim.limit.durationFromTokens(-tokens)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Decide result</span></span><br><span class="line">ok := n &lt;= lim.burst &amp;&amp; waitDuration &lt;= maxFutureReserve</span><br><span class="line"><span class="comment">// Prepare reservation</span></span><br><span class="line">r := Reservation&#123;</span><br><span class="line">ok:    ok,</span><br><span class="line">lim:   lim,</span><br><span class="line">limit: lim.limit,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">r.tokens = n</span><br><span class="line">r.timeToAct = now.Add(waitDuration)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Update state</span></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">lim.last = now</span><br><span class="line">lim.tokens = tokens</span><br><span class="line">lim.lastEvent = r.timeToAct</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">lim.last = last</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// advance calculates and returns an updated state for lim resulting from the passage of time.</span></span><br><span class="line"><span class="comment">// lim is not changed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span> <span class="title">advance</span><span class="params">(now time.Time)</span> <span class="params">(newNow time.Time, newLast time.Time, newTokens <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">last := lim.last</span><br><span class="line"><span class="keyword">if</span> now.Before(last) &#123;</span><br><span class="line">last = now</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Avoid making delta overflow below when last is very old.</span></span><br><span class="line">maxElapsed := lim.limit.durationFromTokens(<span class="keyword">float64</span>(lim.burst) - lim.tokens)</span><br><span class="line">elapsed := now.Sub(last)</span><br><span class="line"><span class="keyword">if</span> elapsed &gt; maxElapsed &#123;</span><br><span class="line">elapsed = maxElapsed</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Calculate the new number of tokens, due to time that passed.</span></span><br><span class="line">delta := lim.limit.tokensFromDuration(elapsed)</span><br><span class="line">tokens := lim.tokens + delta</span><br><span class="line"><span class="keyword">if</span> burst := <span class="keyword">float64</span>(lim.burst); tokens &gt; burst &#123;</span><br><span class="line">tokens = burst</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> now, last, tokens</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// durationFromTokens is a unit conversion function from the number of tokens to the duration</span></span><br><span class="line"><span class="comment">// of time it takes to accumulate them at a rate of limit tokens per second.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(limit Limit)</span> <span class="title">durationFromTokens</span><span class="params">(tokens <span class="keyword">float64</span>)</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line">seconds := tokens / <span class="keyword">float64</span>(limit)</span><br><span class="line"><span class="keyword">return</span> time.Nanosecond * time.Duration(<span class="number">1e9</span>*seconds)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// tokensFromDuration is a unit conversion function from a time duration to the number of tokens</span></span><br><span class="line"><span class="comment">// which could be accumulated during that duration at a rate of limit tokens per second.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(limit Limit)</span> <span class="title">tokensFromDuration</span><span class="params">(d time.Duration)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> d.Seconds() * <span class="keyword">float64</span>(limit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然在某些情况下使用单个全局速率限制器非常有用，但另一种常见情况是基于IP地址或API密钥等标识符为每个用户实施速率限制器。我们将使用IP地址作为标识符。简单实现代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"golang.org/x/time/rate"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// Create a custom visitor struct which holds the rate limiter for each</span></span><br><span class="line"><span class="comment">// visitor and the last time that the visitor was seen.</span></span><br><span class="line"><span class="keyword">type</span> visitor <span class="keyword">struct</span> &#123;</span><br><span class="line">    limiter  *rate.Limiter</span><br><span class="line">    lastSeen time.Time</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Change the the map to hold values of the type visitor.</span></span><br><span class="line"><span class="keyword">var</span> visitors = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*visitor)</span><br><span class="line"><span class="keyword">var</span> mtx sync.Mutex</span><br><span class="line"><span class="comment">// Run a background goroutine to remove old entries from the visitors map.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> cleanupVisitors()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addVisitor</span><span class="params">(ip <span class="keyword">string</span>)</span> *<span class="title">rate</span>.<span class="title">Limiter</span></span> &#123;</span><br><span class="line">    limiter := rate.NewLimiter(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">    mtx.Lock()</span><br><span class="line">    <span class="comment">// Include the current time when creating a new visitor.</span></span><br><span class="line">    visitors[ip] = &amp;visitor&#123;limiter, time.Now()&#125;</span><br><span class="line">    mtx.Unlock()</span><br><span class="line">    <span class="keyword">return</span> limiter</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getVisitor</span><span class="params">(ip <span class="keyword">string</span>)</span> *<span class="title">rate</span>.<span class="title">Limiter</span></span> &#123;</span><br><span class="line">    mtx.Lock()</span><br><span class="line">    v, exists := visitors[ip]</span><br><span class="line">    <span class="keyword">if</span> !exists &#123;</span><br><span class="line">        mtx.Unlock()</span><br><span class="line">        <span class="keyword">return</span> addVisitor(ip)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Update the last seen time for the visitor.</span></span><br><span class="line">    v.lastSeen = time.Now()</span><br><span class="line">    mtx.Unlock()</span><br><span class="line">    <span class="keyword">return</span> v.limiter</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Every minute check the map for visitors that haven't been seen for</span></span><br><span class="line"><span class="comment">// more than 3 minutes and delete the entries.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cleanupVisitors</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        time.Sleep(time.Minute)</span><br><span class="line">        mtx.Lock()</span><br><span class="line">        <span class="keyword">for</span> ip, v := <span class="keyword">range</span> visitors &#123;</span><br><span class="line">            <span class="keyword">if</span> time.Now().Sub(v.lastSeen) &gt; <span class="number">3</span>*time.Minute &#123;</span><br><span class="line">                <span class="built_in">delete</span>(visitors, ip)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mtx.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">limit</span><span class="params">(next http.Handler)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        limiter := getVisitor(r.RemoteAddr)</span><br><span class="line">        <span class="keyword">if</span> limiter.Allow() == <span class="literal">false</span> &#123;</span><br><span class="line">            http.Error(w, http.StatusText(<span class="number">429</span>), http.StatusTooManyRequests)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        next.ServeHTTP(w, r)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="窗口限流"><a href="#窗口限流" class="headerlink" title="窗口限流"></a>窗口限流</h2><h3 id="Fixed-Window"><a href="#Fixed-Window" class="headerlink" title="Fixed Window"></a>Fixed Window</h3><p>固定窗口算法，设置一个时间段内（窗口）接收的请求数，超过的这个请求数的请求会被丢弃。</p><ul><li>窗口通常选择人们熟悉的时间段：1 分钟／1小时</li><li>窗口的起始时间通常是当前时间取地板（floor），比如 12:00:03 所在的窗口 （以一分钟的窗口为例）就是 12:00:00 - 12:01:00<br>和漏桶相比，能够让新来的请求也能够被处理到，但存在缺点：</li><li>在窗口的起始时间，最差情况下可能会带来 2 倍的流量</li><li>很多消费者可能都在等待窗口被重置，造成惊群效应（惊群效应：当某一资源可用时，n个进程/线程会惊醒，竞争资源。导致n-1个进程/线程做了无效的调度,上下文切换，cpu瞬时增高）</li></ul><h3 id="Sliding-Log"><a href="#Sliding-Log" class="headerlink" title="Sliding Log"></a>Sliding Log</h3><p>滑动日志算法，利用记录下来的用户的请求时间，请求数，当该用户的一个新的 请求进来时，比较这个用户在这个窗口内的请求数是否超过了限定值，超过的话 就拒绝这个请求。<br>优点：</p><ul><li>避免了固定窗口算法在窗口边界可能出现的两倍流量问题</li><li>由于是针对每个用户进行统计的，不会引发惊群效应<br>缺点：</li><li>需要保存大量的请求日志</li><li>每个请求都需要考虑该用户之前的请求情况，在分布式系统中尤其难做到</li></ul><h3 id="Sliding-Window"><a href="#Sliding-Window" class="headerlink" title="Sliding Window"></a>Sliding Window</h3><p>滑动窗口算法，结合了固定窗口算法的低开销和滑动日志算法能够解决的边界情况。</p><ul><li>为每个窗口进行请求量的计数</li><li>结合上一个窗口的请求量和这一个窗口已经经过的时间来计算出上限，以此 平滑请求尖锋<br>举例来说，限流的上限是每分钟 10 个请求，窗口大小为 1 分钟，上一个 窗口中总共处理了 6 个请求。现在假设这个新的窗口已经经过了 20 秒，那么 到目前为止允许的请求上限就是 <code>10 - 6 * (1 - 20 / 60) = 8</code>。<br>滑动窗口算法是这些算法中最实用的算法：</li><li>避免了漏桶算法带来的饥饿问题</li><li>避免了固定窗口算法的请求量突增的问题</li></ul><h2 id="集群限流"><a href="#集群限流" class="headerlink" title="集群限流"></a>集群限流</h2><p>上述限流方法都是单机限流的范畴，比如为了限制某个资源被每个用户或者商户的访问次数，5s只能访问2次，或者一天只能调用1000次，这种需求，单机限流是无法实现的，这时就需要通过集群限流进行实现。<br>难点在于限流上限都是针对全站的流量设置的，那么每个节点该如何协调各自处理的量呢？</p><h3 id="同步的策略"><a href="#同步的策略" class="headerlink" title="同步的策略"></a>同步的策略</h3><p>解决的方法通常都是使用一个统一的数据库来存放计数，比如 Redis 或者 Cassandra。 数据库中将存放每个窗口和用户的计数值。这种方法的主要问题是需要多访问一次数据库， 以及竞争问题。</p><h3 id="竞争问题"><a href="#竞争问题" class="headerlink" title="竞争问题"></a>竞争问题</h3><p>竞争问题就是当有两个以上的线程同时执行 i += 1 的时候，如果没有同步这 些操作的话，i 的值可能会有多种情况。<br>处理竞争问题可以通过加锁来做，不过在限流的场景下，这样做肯定会成为系统的瓶颈， 毕竟限流时每个请求都会来竞争这个锁。<br>更好的办法是通过 set-then-get 的方法，限流场景中用到的只是计数 +1， 利用这一点以及数据库实现的性能更好的原子操作可以达到我们的目的。</p><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>利用集中式的数据库的另一个问题是每次请求都要查一下数据库带来的延迟开销， 数据库再快也会带来几毫秒的延迟。<br>解决这个问题的方法可以通过在内存里面维护一个计数值，代价是稍微的放松限 流的精确度。通过设置一个定时任务从数据库拿计数值，周期内在内存中维护这 个计数，周期结束时把计数同步到数据库并拿取新的计数，如此往复。<br>这个同步周期往往是做成可以配置的，小的周期能够带来更精确的限流， 大的周期则能减轻数据库的 I/O 压力。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://github.com/yangwenmai/ratelimit" target="_blank" rel="noopener">基于令牌桶算法和漏桶算法来实现的限速限流</a><br><a href="https://github.com/didip/tollbooth" target="_blank" rel="noopener">轻量级限流中间件</a><br><a href="https://www.jianshu.com/p/c02899c30bbd" target="_blank" rel="noopener">漏桶算法&amp;令牌桶算法理解及常用的算法</a><br><a href="https://blog.csdn.net/qq_15437667/article/details/70769084" target="_blank" rel="noopener">go channel实现简单信号量</a><br><a href="https://blog.csdn.net/qq_30505673/article/details/82156834" target="_blank" rel="noopener">go语言生产者消费者信号量实现</a><br><a href="https://blog.csdn.net/micl200110041/article/details/82013032" target="_blank" rel="noopener">Golang实现请求限流的几种办法</a><br><a href="https://blog.csdn.net/weixin_42296449/article/details/90318706" target="_blank" rel="noopener">高并发系统限流-漏桶算法和令牌桶算法</a><br><a href="https://blog.csdn.net/linhui258/article/details/81155622" target="_blank" rel="noopener">谈谈服务限流算法的几种实现</a><br><a href="https://www.cnblogs.com/senlinyang/p/7840304.html" target="_blank" rel="noopener">常用的限流算法</a><br><a href="https://blog.csdn.net/scorpio3k/article/details/53103239" target="_blank" rel="noopener">高并发系统限流中的漏桶算法和令牌桶算法，通过流量整形和速率限制提升稳定性</a><br><a href="https://blog.csdn.net/u012526691/article/details/80333907" target="_blank" rel="noopener">高并发系统限流中的算法</a><br><a href="https://www.jianshu.com/p/ee2c8843f7a9" target="_blank" rel="noopener">限流算法比较与实现</a><br><a href="https://blog.csdn.net/ljj821061514/article/details/52512943" target="_blank" rel="noopener">接口限流算法（关于临界点处理）</a><br><a href="https://blog.csdn.net/u010963948/article/details/79424413" target="_blank" rel="noopener">限流算法的理解和应用场景和实现</a><br><a href="https://blog.csdn.net/second60/article/details/81252106" target="_blank" rel="noopener">高并发中的惊群效应</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么需要限流算法&quot;&gt;&lt;a href=&quot;#为什么需要限流算法&quot; class=&quot;headerlink&quot; title=&quot;为什么需要限流算法&quot;&gt;&lt;/a&gt;为什么需要限流算法&lt;/h1&gt;&lt;p&gt;在高并发系统中，保护系统三大利器：缓存，降级，限流，即主要降低数据库的访问。当请求量
      
    
    </summary>
    
    
      <category term="系统" scheme="http://aemonswift.github.io/categories/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="限流" scheme="http://aemonswift.github.io/categories/%E7%B3%BB%E7%BB%9F/%E9%99%90%E6%B5%81/"/>
    
    
      <category term="系统" scheme="http://aemonswift.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="算法" scheme="http://aemonswift.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>路径规划——Floyd</title>
    <link href="http://aemonswift.github.io/2019/10/25/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E2%80%94%E2%80%94Floyd/"/>
    <id>http://aemonswift.github.io/2019/10/25/路径规划——Floyd/</id>
    <published>2019-10-25T01:22:00.000Z</published>
    <updated>2019-10-25T02:28:56.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h1><p>$\color{red}{主要用来求解：}$任意两点的最短路径。该算法采用了动态规划的思想。<br>$\color{red}{思想如下：}$A到B，可以经历中转站得来降低成本；当考虑了所有的中转站的时候，则可以得到此图在A到B的最低成本。<br>$\color{red}{适用范围：}$解决多源路径问题。</p><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ol><li>初始化边矩阵M；</li><li>从U中选取顶点k加入S中，并将此元素从U中移除；</li><li>以k为中转站，更新边矩阵M的信息；</li><li>重复步骤2和3，直到所有顶点都包含在S中。<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><img alt="无向图" data-src="https://cdn.jsdelivr.net/gh/AemonSwift/AemonSwift@latest/AemonSwift.github.io/images/directpicture.jpg" class="lozad"></li></ol><p>a. 初始化M矩阵,即经过A点的M矩阵</p><table><thead><tr><th align="center">*</th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th><th align="center">E</th><th align="center">F</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">0</td><td align="center">6</td><td align="center">3</td><td align="center">$\infty$</td><td align="center">$\infty$</td><td align="center">$\infty$</td></tr><tr><td align="center">B</td><td align="center">6</td><td align="center">0</td><td align="center">2</td><td align="center">5</td><td align="center">$\infty$</td><td align="center">$\infty$</td></tr><tr><td align="center">C</td><td align="center">3</td><td align="center">2</td><td align="center">0</td><td align="center">3</td><td align="center">4</td><td align="center">$\infty$</td></tr><tr><td align="center">D</td><td align="center">$\infty$</td><td align="center">5</td><td align="center">3</td><td align="center">0</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center">E</td><td align="center">$\infty$</td><td align="center">$\infty$</td><td align="center">4</td><td align="center">2</td><td align="center">0</td><td align="center">5</td></tr><tr><td align="center">F</td><td align="center">$\infty$</td><td align="center">$\infty$</td><td align="center">$\infty$</td><td align="center">3</td><td align="center">5</td><td align="center">0</td></tr></tbody></table><p>b. 考虑经过B点，更新M矩阵</p><table><thead><tr><th align="center">*</th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th><th align="center">E</th><th align="center">F</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">0</td><td align="center">6</td><td align="center">3</td><td align="center">11</td><td align="center">$\infty$</td><td align="center">$\infty$</td></tr><tr><td align="center">B</td><td align="center">6</td><td align="center">0</td><td align="center">2</td><td align="center">5</td><td align="center">$\infty$</td><td align="center">$\infty$</td></tr><tr><td align="center">C</td><td align="center">3</td><td align="center">2</td><td align="center">0</td><td align="center">3</td><td align="center">4</td><td align="center">$\infty$</td></tr><tr><td align="center">D</td><td align="center">11</td><td align="center">5</td><td align="center">3</td><td align="center">0</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center">E</td><td align="center">$\infty$</td><td align="center">$\infty$</td><td align="center">4</td><td align="center">2</td><td align="center">0</td><td align="center">5</td></tr><tr><td align="center">F</td><td align="center">$\infty$</td><td align="center">$\infty$</td><td align="center">$\infty$</td><td align="center">3</td><td align="center">5</td><td align="center">0</td></tr></tbody></table><p>c. 考虑经过C点，更新M矩阵</p><table><thead><tr><th align="center">*</th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th><th align="center">E</th><th align="center">F</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">0</td><td align="center">5</td><td align="center">3</td><td align="center">6</td><td align="center">7</td><td align="center">$\infty$</td></tr><tr><td align="center">B</td><td align="center">5</td><td align="center">0</td><td align="center">2</td><td align="center">5</td><td align="center">6</td><td align="center">$\infty$</td></tr><tr><td align="center">C</td><td align="center">3</td><td align="center">2</td><td align="center">0</td><td align="center">3</td><td align="center">4</td><td align="center">$\infty$</td></tr><tr><td align="center">D</td><td align="center">6</td><td align="center">5</td><td align="center">3</td><td align="center">0</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center">E</td><td align="center">7</td><td align="center">6</td><td align="center">4</td><td align="center">2</td><td align="center">0</td><td align="center">5</td></tr><tr><td align="center">F</td><td align="center">$\infty$</td><td align="center">$\infty$</td><td align="center">$\infty$</td><td align="center">3</td><td align="center">5</td><td align="center">0</td></tr></tbody></table><p>d. 考虑经过D点，更新M矩阵</p><table><thead><tr><th align="center">*</th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th><th align="center">E</th><th align="center">F</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">0</td><td align="center">5</td><td align="center">3</td><td align="center">6</td><td align="center">7</td><td align="center">9</td></tr><tr><td align="center">B</td><td align="center">5</td><td align="center">0</td><td align="center">2</td><td align="center">5</td><td align="center">6</td><td align="center">8</td></tr><tr><td align="center">C</td><td align="center">3</td><td align="center">2</td><td align="center">0</td><td align="center">3</td><td align="center">4</td><td align="center">6</td></tr><tr><td align="center">D</td><td align="center">6</td><td align="center">5</td><td align="center">3</td><td align="center">0</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center">E</td><td align="center">7</td><td align="center">6</td><td align="center">4</td><td align="center">2</td><td align="center">0</td><td align="center">5</td></tr><tr><td align="center">F</td><td align="center">9</td><td align="center">8</td><td align="center">6</td><td align="center">3</td><td align="center">5</td><td align="center">0</td></tr></tbody></table><p>e. 考虑经过E点，更新M矩阵</p><table><thead><tr><th align="center">*</th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th><th align="center">E</th><th align="center">F</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">0</td><td align="center">5</td><td align="center">3</td><td align="center">6</td><td align="center">7</td><td align="center">9</td></tr><tr><td align="center">B</td><td align="center">5</td><td align="center">0</td><td align="center">2</td><td align="center">5</td><td align="center">6</td><td align="center">8</td></tr><tr><td align="center">C</td><td align="center">3</td><td align="center">2</td><td align="center">0</td><td align="center">3</td><td align="center">4</td><td align="center">6</td></tr><tr><td align="center">D</td><td align="center">6</td><td align="center">5</td><td align="center">3</td><td align="center">0</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center">E</td><td align="center">7</td><td align="center">6</td><td align="center">4</td><td align="center">2</td><td align="center">0</td><td align="center">5</td></tr><tr><td align="center">F</td><td align="center">9</td><td align="center">8</td><td align="center">6</td><td align="center">3</td><td align="center">5</td><td align="center">0</td></tr></tbody></table><p>f. 考虑经过F点，更新M矩阵</p><table><thead><tr><th align="center">*</th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th><th align="center">E</th><th align="center">F</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">0</td><td align="center">5</td><td align="center">3</td><td align="center">6</td><td align="center">7</td><td align="center">9</td></tr><tr><td align="center">B</td><td align="center">5</td><td align="center">0</td><td align="center">2</td><td align="center">5</td><td align="center">6</td><td align="center">8</td></tr><tr><td align="center">C</td><td align="center">3</td><td align="center">2</td><td align="center">0</td><td align="center">3</td><td align="center">4</td><td align="center">6</td></tr><tr><td align="center">D</td><td align="center">6</td><td align="center">5</td><td align="center">3</td><td align="center">0</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center">E</td><td align="center">7</td><td align="center">6</td><td align="center">4</td><td align="center">2</td><td align="center">0</td><td align="center">5</td></tr><tr><td align="center">F</td><td align="center">9</td><td align="center">8</td><td align="center">6</td><td align="center">3</td><td align="center">5</td><td align="center">0</td></tr></tbody></table><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><h2 id="头文件描述"><a href="#头文件描述" class="headerlink" title="头文件描述"></a>头文件描述</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pragma once</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stringstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphDG</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> pointSum;</span><br><span class="line"><span class="keyword">int</span> edge;</span><br><span class="line"><span class="keyword">int</span> **adjacentMat；</span><br><span class="line"><span class="keyword">int</span> **dis;</span><br><span class="line"><span class="keyword">int</span> **path;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">intToString</span><span class="params">(<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkEdgeValue</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> weight)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">GraphDG(<span class="keyword">int</span> pointSum,<span class="keyword">int</span> edge);</span><br><span class="line">~GraphDG();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createGraph</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMinPath</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"Floyd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> INT_MAX=<span class="number">2</span>^<span class="number">32</span><span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">GraphDG::GraphDG(<span class="keyword">int</span> pointSum,<span class="keyword">int</span> edge)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;pointSum=pointSum;</span><br><span class="line"><span class="keyword">this</span>-&gt;edge=edge;</span><br><span class="line"><span class="keyword">this</span>-&gt;adjacentMat=<span class="keyword">new</span> <span class="keyword">int</span>*[<span class="keyword">this</span>-&gt;pointSum];</span><br><span class="line"><span class="keyword">this</span>-&gt;dis=<span class="keyword">new</span> <span class="keyword">int</span>*[<span class="keyword">this</span>-&gt;pointSum];</span><br><span class="line"><span class="keyword">this</span>-&gt;path=<span class="keyword">new</span> <span class="keyword">int</span>*[<span class="keyword">this</span>-&gt;pointSum];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>-&gt;pointSum;i++)&#123;</span><br><span class="line">adjacentMat[i]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>-&gt;pointSum];</span><br><span class="line">dis[i]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>-&gt;pointSum];</span><br><span class="line">path[i]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>-&gt;pointSum];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="keyword">this</span>-&gt;pointSum;j++)&#123;</span><br><span class="line">adjacentMat[i][j]=INT_MAX;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GraphDG::~GraphDG()&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>-&gt;pointSum;i++)&#123;</span><br><span class="line"><span class="keyword">delete</span> adjacentMat[i];</span><br><span class="line"><span class="keyword">delete</span> dis[i];</span><br><span class="line"><span class="keyword">delete</span> path[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> adjacentMat;</span><br><span class="line"><span class="keyword">delete</span> dis;</span><br><span class="line"><span class="keyword">delete</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> GraphDG::checkEdgeValue(<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> weight)&#123;</span><br><span class="line"><span class="keyword">if</span> (start&lt;<span class="number">1</span>||end&lt;<span class="number">1</span>||start&gt;end||end&gt;pointSum||weight&lt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GraphDG::createGraph(<span class="keyword">int</span> kind)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入每条边的起点和终点（顶点编号从1开始）以及其权重"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> start,end,weight;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>-&gt;edge;i++&gt;)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;start&gt;&gt;end&gt;&gt;weight;</span><br><span class="line"><span class="keyword">while</span>(!<span class="keyword">this</span>-&gt;checkEdgeValue(start,end,weight))&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入的边的信息不合法，请重新输入"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; start &gt;&gt; end &gt;&gt; weight;</span><br><span class="line">&#125;</span><br><span class="line">adjacentMat[start<span class="number">-1</span>][end<span class="number">-1</span>]=weight;</span><br><span class="line"><span class="comment">//变成无向图</span></span><br><span class="line"><span class="keyword">if</span> (kind==<span class="number">2</span>)&#123;</span><br><span class="line">adjacentMat[end<span class="number">-1</span>][start<span class="number">-1</span>]=weight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GraphDG::print()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"图的邻接矩阵为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row=<span class="number">0</span>;row&lt;<span class="keyword">this</span>-&gt;pointSum;row++&gt;)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;<span class="keyword">this</span>-&gt;pointSum;col++)&#123;</span><br><span class="line"><span class="keyword">if</span> adjacentMat[row][col]==INT_MAX&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"i "</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;adjacentMat[row][col]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//思想在于：A到B，可以经历中转站得来降低成本；当考虑了所有的中转站的时候，则可以得到此图在A到B的最低成本。——动态规划思想</span></span><br><span class="line"><span class="keyword">void</span> GraphDG::Floyd()&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row=<span class="number">0</span>;row&lt;<span class="keyword">this</span>-&gt;pointSum;row++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;<span class="keyword">this</span>-&gt;pointSum;col++)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;dis[row][col]=<span class="keyword">this</span>-&gt;adjacentMat[row][col];</span><br><span class="line"><span class="keyword">this</span>-&gt;path[row][col]=col;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> temp =<span class="number">0</span>;temp&lt;<span class="keyword">this</span>-&gt;pointSum;temp++)&#123; <span class="comment">//temp为中转站</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>-&gt;pointSum;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="keyword">this</span>-&gt;pointSum;j++)&#123;</span><br><span class="line">select=(dis[row][temp] == INT_MAX || dis[temp][col] == INT_MAX) ? INT_MAX : (dis[row][temp] + dis[temp][col]);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>-&gt;dis[i][j]&gt;select)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;dis[i][j]=select;</span><br><span class="line"><span class="keyword">this</span>-&gt;path[i][j]=<span class="keyword">this</span>-&gt;path[i][temp];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GraphDG::printMinPath()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"各个顶点对的最短路径："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row=<span class="number">0</span>;row&lt;<span class="keyword">this</span>-&gt;pointSum;row++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;<span class="keyword">this</span>-&gt;pointSum;col++)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"v"</span>&lt;&lt;intToString(row+<span class="number">1</span>)&lt;&lt;<span class="string">"--"</span>&lt;&lt;<span class="string">"v"</span>&lt;&lt;intToString(col+<span class="number">1</span>)&lt;&lt;<span class="string">"weight:"</span></span><br><span class="line">&lt;&lt;<span class="keyword">this</span>-&gt;dis[row][col]&lt;&lt;<span class="string">"path:"</span>&lt;&lt;<span class="string">"v"</span>&lt;&lt;intToString(row+<span class="number">1</span>);</span><br><span class="line">temp=path[row][col];</span><br><span class="line"><span class="keyword">while</span>(temp!=col)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"--&gt;"</span>&lt;&lt;<span class="string">"v"</span>&lt;&lt;intToString(temp+<span class="number">1</span>);</span><br><span class="line">temp=path[temp][col];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"--&gt;"</span>&lt;&lt;<span class="string">"v"</span>&lt;&lt;intToString(col+<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> GraphDG::intToString(<span class="keyword">int</span> target)&#123;</span><br><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line">ss&lt;&lt;target;</span><br><span class="line"><span class="keyword">return</span> ss&gt;&gt;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试函数"><a href="#测试函数" class="headerlink" title="测试函数"></a>测试函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Floyd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> pointSum,<span class="keyword">int</span> edge)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pointSum&lt;=<span class="number">1</span>||edge&lt;=<span class="number">0</span>||(pointSum<span class="number">-1</span>)*pointSum&lt;edge)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pointSum,edge,kind;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入图的种类：1代表有向图，2代表无向图"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;kind;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (kind==<span class="number">1</span>||kind==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入的图的种类编号不合法，请重新输入：1代表有向图，2代表无向图"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; kind;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入图的顶点个数和边的条数："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; pointSum &gt;&gt; edge;</span><br><span class="line">    <span class="keyword">while</span> (!check(pointSum, edge)) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入的数值不合法，请重新输入"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; pointSum &gt;&gt; edge;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">GraphDG <span class="title">graph</span><span class="params">(pointSum,edge)</span></span>;</span><br><span class="line">    graph.createGraph(kind);</span><br><span class="line">    graph.print();</span><br><span class="line">    graph.Floy();</span><br><span class="line">    graph.printMinPath();</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入参数</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 7 12</span></span><br><span class="line"><span class="comment">// 1 2 12</span></span><br><span class="line"><span class="comment">// 1 6 16</span></span><br><span class="line"><span class="comment">// 1 7 14</span></span><br><span class="line"><span class="comment">// 2 3 10</span></span><br><span class="line"><span class="comment">// 2 6 7</span></span><br><span class="line"><span class="comment">// 3 4 3</span></span><br><span class="line"><span class="comment">// 3 5 5</span></span><br><span class="line"><span class="comment">// 3 6 6</span></span><br><span class="line"><span class="comment">// 4 5 4</span></span><br><span class="line"><span class="comment">// 5 6 2</span></span><br><span class="line"><span class="comment">// 5 7 8</span></span><br><span class="line"><span class="comment">// 6 7 9</span></span><br></pre></td></tr></table></figure><h1 id="算法缺陷"><a href="#算法缺陷" class="headerlink" title="算法缺陷"></a>算法缺陷</h1><p>可以求有负权值的边，但是不能有负回路。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;思想&quot;&gt;&lt;a href=&quot;#思想&quot; class=&quot;headerlink&quot; title=&quot;思想&quot;&gt;&lt;/a&gt;思想&lt;/h1&gt;&lt;p&gt;$\color{red}{主要用来求解：}$任意两点的最短路径。该算法采用了动态规划的思想。&lt;br&gt;$\color{red}{思想如下：}$
      
    
    </summary>
    
    
      <category term="算法" scheme="http://aemonswift.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="路径规划" scheme="http://aemonswift.github.io/categories/%E7%AE%97%E6%B3%95/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"/>
    
    
      <category term="算法" scheme="http://aemonswift.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="路径规划" scheme="http://aemonswift.github.io/tags/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>路径规划——Dijkstra</title>
    <link href="http://aemonswift.github.io/2019/10/24/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E2%80%94%E2%80%94Dijkstra/"/>
    <id>http://aemonswift.github.io/2019/10/24/路径规划——Dijkstra/</id>
    <published>2019-10-24T07:03:06.000Z</published>
    <updated>2019-10-25T01:45:09.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h1><p>$\color{red}{主要用来求解：}$从起始点到其他所有点的最短路径。该算法采用了贪心的思想。<br>$\color{red}{思想如下：}$A到B可以有多个中转站集合U，如何选择中转站？本算法选择最低的成本的中转站，即将C1加入到需要走的中转站集合S中，在目前集合S情况下，得到了A到所有各站的成本，在此成本基础上选择最低的成本加入到需要走的中转站集合S中，重复上述操作。<br>$\color{red}{适用范围：}$解决单源路径问题。</p><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ol><li>初始化时，S只含有源节点；</li><li>从U中选取一个距离v最小的顶点k加入S中（该选定的距离就是v到k的最短路径长度），并将此元素从U中移除；</li><li>以k为新考虑的中间点，修改U中各顶点的距离；若从源节点v到顶点u的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值是顶点k的距离加上k到u的距离；</li><li>重复步骤2和3，直到所有顶点都包含在S中。<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><img alt="无向图" data-src="https://cdn.jsdelivr.net/gh/AemonSwift/AemonSwift@latest/AemonSwift.github.io/images/directpicture.jpg" class="lozad"><br>从A开始出发，到其他所有点的最短距离和路径<table><thead><tr><th align="center">步骤</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">初始化距离$dis=[0,6,3,\infty,\infty,\infty,\infty]$，此时S={A},U={B,C,D,E,F}</td></tr><tr><td align="center">2</td><td align="center">排除S中的点，寻找dis中最小距离的点C,此时距离为$dis=[0,5,3,6,7,\infty]$，此时S={A,C},U={B,D,E,F}</td></tr><tr><td align="center">3</td><td align="center">排除S中的点，寻找dis中最小距离的点B，此时距离变为$dis=[0,5,3,6,7,\infty]$，此时S={A,C,B},U={D,E,F}</td></tr><tr><td align="center">4</td><td align="center">排除S中的点，寻找dis中最小距离的点D，此时距离变为$dis=[0,5,3,6,7,9]$，此时S={A,C,B,D},U={E,F}</td></tr><tr><td align="center">5</td><td align="center">排除S中的点，寻找dis中最小距离的点E，此时距离变为$dis=[0,5,3,6,7,9]$，此时S={A,C,B,D,E},U={F}</td></tr><tr><td align="center">6</td><td align="center">排除S中的点，寻找dis中最小距离的点F，此时距离变为$dis=[0,5,3,6,7,9]$，此时S={A,C,B,D,F},U={}</td></tr></tbody></table></li></ol><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><h2 id="头文件描述"><a href="#头文件描述" class="headerlink" title="头文件描述"></a>头文件描述</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dijkstra.h</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">pragma</span> once <span class="comment">//pragma once是一个比较常用的C/C++声明，只要在头文件的最开始加入这条杂注，就能够保证头文件只被编译一次。</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dis</span>&#123;</span></span><br><span class="line"><span class="built_in">string</span> path;</span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">bool</span> visit;</span><br><span class="line"><span class="keyword">int</span> prePoint; <span class="comment">//记录到当前节点的上一个节点是谁</span></span><br><span class="line">Dis()&#123;</span><br><span class="line">visit=<span class="literal">false</span>;</span><br><span class="line">value=<span class="number">0</span>;</span><br><span class="line">path=<span class="string">""</span>;</span><br><span class="line">minPath=<span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphDG</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> pointNum;</span><br><span class="line"><span class="keyword">int</span> edge;</span><br><span class="line"><span class="keyword">int</span> **adjacentMat；</span><br><span class="line">Dis*dis;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">intToString</span><span class="params">(<span class="keyword">int</span> target)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkEdgeValue</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> weight)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">GraphDG(<span class="keyword">int</span> pointNum,<span class="keyword">int</span> edge);</span><br><span class="line">~GraphDG();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createGraph</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resloveMinPath</span><span class="params">(<span class="keyword">int</span> begin)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSearchPath</span><span class="params">(<span class="keyword">int</span> begin)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMinPath</span><span class="params">(<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"Dijkstra.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> INT_MAX=<span class="number">2</span>^<span class="number">31</span><span class="number">-1</span>;</span><br><span class="line">GraphDG::GraphDG(<span class="keyword">int</span> pointNum,<span class="keyword">int</span> edge)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;pointNum=pointNum;</span><br><span class="line"><span class="keyword">this</span>-&gt;edge=edge;</span><br><span class="line">adjacentMat=<span class="keyword">new</span> <span class="keyword">int</span>* [<span class="keyword">this</span>-&gt;pointNum];</span><br><span class="line">dis=<span class="keyword">new</span> Dis[<span class="keyword">this</span>-&gt;pointNum];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>-&gt;pointNum;i++)&#123;</span><br><span class="line">adjacentMat=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>-&gt;pointNum];</span><br><span class="line"><span class="function"><span class="keyword">for</span> <span class="title">int</span><span class="params">(j=<span class="number">0</span>;j&lt;<span class="keyword">this</span>-&gt;pointNum;j++)</span></span>&#123;</span><br><span class="line">adjacentMat[i][j]=INT_MAX; <span class="comment">//开始赋值无穷大</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GraphDG::~GraphDG() &#123;</span><br><span class="line"><span class="keyword">delete</span> dis;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>-&gt;pointNum;i++)&#123;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;adjacentMat[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;adjacentMat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> GraphDG::checkEdgeValue(<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> weight)&#123;</span><br><span class="line"><span class="keyword">if</span> (start&lt;<span class="number">1</span>||end&lt;<span class="number">1</span>||start&gt;<span class="keyword">this</span>-&gt;pointNum||end&gt;<span class="keyword">this</span>-&gt;pointNum||weight&lt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GraphDG::createGraph()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入每条边的起点和终点（顶点编号从1开始）以及其权重"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> start,end,weight,count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(count!=<span class="keyword">this</span>-&gt;edge)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;start&gt;&gt;end&gt;&gt;weight;</span><br><span class="line"><span class="keyword">while</span>(!<span class="keyword">this</span>-&gt;checkEdgeValue(start,end,weight))&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入的边的信息不合法，请重新输入"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; start &gt;&gt; end &gt;&gt; weight;</span><br><span class="line">&#125;</span><br><span class="line">adjacentMat[start<span class="number">-1</span>][end<span class="number">-1</span>]=weight;</span><br><span class="line"><span class="comment">// adjacentMat[end-1][start-1]=weight 加上这句为无向边</span></span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GraphDG::print(<span class="keyword">int</span> begin)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"图的邻接矩阵为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row=<span class="number">0</span>;row&lt;<span class="keyword">this</span>-&gt;pointNum;col++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;<span class="keyword">this</span>-&gt;pointNum;i++;col++)&#123;</span><br><span class="line"><span class="keyword">if</span> (adjacentMat[row][col]==INT_MAX)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"infinity"</span>；</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;adjacentMat[row][col];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GraphDG::printSearchPath(<span class="keyword">int</span> begin)&#123;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line">str=<span class="string">"v"</span>+intToString(begin);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"以"</span>&lt;&lt;str&lt;&lt;<span class="string">"为起点的图的最短路径为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i!=<span class="keyword">this</span>-&gt;pointNum;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[i].value!=INT_MAX)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dis[i].path &lt;&lt; <span class="string">"="</span> &lt;&lt; dis[i].value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dis[i].path &lt;&lt; <span class="string">"是无最短路径的"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GraphDG::printMinpath(<span class="keyword">int</span> begin,<span class="keyword">int</span> end)&#123;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">int</span> prePoint=dis[end].prePoint;</span><br><span class="line"><span class="keyword">while</span>(prePoint&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">proPoint=dis[prePoint].prePoint;</span><br><span class="line"><span class="keyword">if</span> (prePoint==proPoint)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">str=intToString(prePoint+<span class="number">1</span>)+<span class="string">" "</span>+str;</span><br><span class="line">prePoint=proPoint;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GraphDG::Dijkstra(<span class="keyword">int</span> begin)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>-&gt;pointNum;i++)&#123;</span><br><span class="line">dis[i].path=<span class="string">"v"</span>+intToString(begin)+<span class="string">"--&gt;v"</span>+intToString(i+<span class="number">1</span>);</span><br><span class="line">dis[i].value=adjacentMat[begin<span class="number">-1</span>][i];</span><br><span class="line">dis[i].prePoint=begin;</span><br><span class="line">&#125;</span><br><span class="line">dis[begin<span class="number">-1</span>].value=<span class="number">0</span>;</span><br><span class="line">dis[begin<span class="number">-1</span>].visit=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">1</span>;count&lt;<span class="keyword">this</span>-&gt;pointNum;count++)&#123;</span><br><span class="line"><span class="comment">//找加入的最小值对应的下标</span></span><br><span class="line"><span class="keyword">int</span> temp=<span class="number">0</span>,min=INT_MAX;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>-&gt;pointNum;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!dis[i].visit&amp;&amp;dis[i].value&lt;INT_MAX)&#123;</span><br><span class="line">min=dis[i].value;</span><br><span class="line">temp=i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dis[temp].visit=<span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 计算剩余点的最短路径</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>-&gt;pointNum;i++&gt;)&#123;</span><br><span class="line"><span class="comment">//注意这里的条件adjacentMat[temp][i]!=INT_MAX必须加，不然会出现溢出，从而造成程序异常</span></span><br><span class="line"><span class="keyword">if</span>(!dis[i].visit&amp;&amp;adjacentMat[temp][i]!=INT_MAX&amp;&amp;dis[temp].value+adjacentMat[temp][i]&lt;dis[i].value)&#123;</span><br><span class="line">dis[i].value=dis[temp].value+adjacentMat[temp][i];</span><br><span class="line">dis[i].path=dis[temp].path+<span class="string">"--&gt;v"</span>+intToString(i+<span class="number">1</span>);</span><br><span class="line">dis[i].prePoint=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> GraphDG::intToString(<span class="keyword">int</span> target)&#123;</span><br><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line">ss&lt;&lt;target;</span><br><span class="line"><span class="keyword">return</span> ss&gt;&gt;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试函数"><a href="#测试函数" class="headerlink" title="测试函数"></a>测试函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Dijkstra.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> pointNum,<span class="keyword">int</span> edge)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pointNum&lt;=<span class="number">1</span>||edge&lt;=<span class="number">0</span>||(pointNum<span class="number">-1</span>)*pointNum/<span class="number">2</span>&lt;edge)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pointNum,edge;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入图的顶点个数和边的条数："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; pointNum &gt;&gt; edge;</span><br><span class="line">    <span class="keyword">while</span> (!check(vexnum, edge)) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入的数值不合法，请重新输入"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; pointNum &gt;&gt; edge;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">GraphDG <span class="title">grpah</span><span class="params">(pointNum,edge)</span></span>;</span><br><span class="line">    graph.createGraph();</span><br><span class="line">    graph.print();</span><br><span class="line">    graph.Dijkstra();</span><br><span class="line">    graph.printSearchPath();</span><br><span class="line">    graph.printMinPath();</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输入参数</span></span><br><span class="line"><span class="comment">// 6 8</span></span><br><span class="line"><span class="comment">// 1 3 10</span></span><br><span class="line"><span class="comment">// 1 5 30</span></span><br><span class="line"><span class="comment">// 1 6 100</span></span><br><span class="line"><span class="comment">// 2 3 5</span></span><br><span class="line"><span class="comment">// 3 4 50</span></span><br><span class="line"><span class="comment">// 4 6 10</span></span><br><span class="line"><span class="comment">// 5 6 60</span></span><br><span class="line"><span class="comment">// 5 4 20</span></span><br></pre></td></tr></table></figure><h1 id="算法缺陷"><a href="#算法缺陷" class="headerlink" title="算法缺陷"></a>算法缺陷</h1><p>若权重为负边的时候，此算法失效。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;思想&quot;&gt;&lt;a href=&quot;#思想&quot; class=&quot;headerlink&quot; title=&quot;思想&quot;&gt;&lt;/a&gt;思想&lt;/h1&gt;&lt;p&gt;$\color{red}{主要用来求解：}$从起始点到其他所有点的最短路径。该算法采用了贪心的思想。&lt;br&gt;$\color{red}{思想如
      
    
    </summary>
    
    
      <category term="算法" scheme="http://aemonswift.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="路径规划" scheme="http://aemonswift.github.io/categories/%E7%AE%97%E6%B3%95/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"/>
    
    
      <category term="算法" scheme="http://aemonswift.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="路径规划" scheme="http://aemonswift.github.io/tags/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>冒泡算法及其优化</title>
    <link href="http://aemonswift.github.io/2019/10/23/%E5%86%92%E6%B3%A1%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    <id>http://aemonswift.github.io/2019/10/23/冒泡算法及其优化/</id>
    <published>2019-10-23T07:01:32.000Z</published>
    <updated>2019-10-24T02:03:06.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h1><p>给你一个数列，对相邻的两个个数进行比较，让大数下沉，或较小的数字进行上浮。</p><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><h2 id="一般实现方法"><a href="#一般实现方法" class="headerlink" title="一般实现方法"></a>一般实现方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len-i<span class="number">-1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                tmp=arr[j];</span><br><span class="line">                arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述算法实现的缺陷：若排到一定时候，当数列再也没有发生交换（即顺序已经排好），但仍然进行循环。</p><h2 id="优化1——引入有序标记"><a href="#优化1——引入有序标记" class="headerlink" title="优化1——引入有序标记"></a>优化1——引入有序标记</h2><p>针对一般实现方法，引入一个标记 <code>flag</code>，来判断是否发生来交换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len-i<span class="number">-1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                tmp=arr[j];</span><br><span class="line">                arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>]=tmp;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述算法实现仍然有着缺陷：若排到一定时候，后面部分都有顺序，而只是前面部分没有顺序，会进行不必要的循环次数。</p><h2 id="优化2——引入位置标记"><a href="#优化2——引入位置标记" class="headerlink" title="优化2——引入位置标记"></a>优化2——引入位置标记</h2><p>针对优化1实现的方法，引入一个位置标记<code>pos</code>，来记录从哪个位置开始时，后面的数据都有顺序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=<span class="number">0</span>,flag=<span class="number">0</span>,pos=<span class="number">0</span>,k=len<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        pos=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                tmp=arr[j];</span><br><span class="line">                arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>]=tmp;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">                pos=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        k=pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还没有方法来继续提高效率？</p><h2 id="优化3——鸡尾酒排序"><a href="#优化3——鸡尾酒排序" class="headerlink" title="优化3——鸡尾酒排序"></a>优化3——鸡尾酒排序</h2><p>回归到冒泡思想：给你一个数列，对相邻的两个个数进行比较，让大数下沉，或较小的数字进行上浮。若一次排序让大数和小数一并都找到，这样大大缩小了第一层的循环次数。——称为鸡尾酒排序。<br><code>pos</code>标记从哪个位置开始时，后面的数据都有顺序。<br><code>prepos</code>标记从哪个位置开始时，前面的数据都有顺序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=<span class="number">0</span>,flag=<span class="number">0</span>,pos=<span class="number">0</span>,k=len<span class="number">-1</span>,prepos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        pos=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;k;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                tmp=arr[j];</span><br><span class="line">                arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>]=tmp;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">                pos=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        k=pos;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=k;j&gt;i;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j]&lt;arr[j<span class="number">-1</span>])&#123;</span><br><span class="line">                tmp=arr[j];</span><br><span class="line">                arr[j]=arr[j<span class="number">-1</span>];</span><br><span class="line">                arr[j<span class="number">-1</span>]=tmp;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">                prepos=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i=prepos<span class="number">-1</span>; <span class="comment">//由于i++操作，故需要进行减1操作，才能回到从哪个位置开始，前面都有序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;思想&quot;&gt;&lt;a href=&quot;#思想&quot; class=&quot;headerlink&quot; title=&quot;思想&quot;&gt;&lt;/a&gt;思想&lt;/h1&gt;&lt;p&gt;给你一个数列，对相邻的两个个数进行比较，让大数下沉，或较小的数字进行上浮。&lt;/p&gt;
&lt;h1 id=&quot;算法实现&quot;&gt;&lt;a href=&quot;#算法实现
      
    
    </summary>
    
    
      <category term="算法" scheme="http://aemonswift.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://aemonswift.github.io/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://aemonswift.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>hello</title>
    <link href="http://aemonswift.github.io/2019/10/21/hello/"/>
    <id>http://aemonswift.github.io/2019/10/21/hello/</id>
    <published>2019-10-21T12:01:35.000Z</published>
    <updated>2019-10-22T00:59:53.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><h2 id="问题为什么重要"><a href="#问题为什么重要" class="headerlink" title="问题为什么重要"></a>问题为什么重要</h2><h2 id="问题目前解决方案有哪些"><a href="#问题目前解决方案有哪些" class="headerlink" title="问题目前解决方案有哪些"></a>问题目前解决方案有哪些</h2><h2 id="问题的难点是什么"><a href="#问题的难点是什么" class="headerlink" title="问题的难点是什么"></a>问题的难点是什么</h2><h2 id="你的创新点是什么"><a href="#你的创新点是什么" class="headerlink" title="你的创新点是什么"></a>你的创新点是什么</h2><h1 id="问题求解"><a href="#问题求解" class="headerlink" title="问题求解"></a>问题求解</h1><h2 id="问题数学描述"><a href="#问题数学描述" class="headerlink" title="问题数学描述"></a>问题数学描述</h2><p>问世间，何许人也！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;h2 id=&quot;问题为什么重要&quot;&gt;&lt;a href=&quot;#问题为什么重要&quot; class=&quot;headerlink&quot; title=&quot;问题为
      
    
    </summary>
    
    
      <category term="音乐" scheme="http://aemonswift.github.io/categories/%E9%9F%B3%E4%B9%90/"/>
    
      <category term="前端" scheme="http://aemonswift.github.io/categories/%E9%9F%B3%E4%B9%90/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="后端" scheme="http://aemonswift.github.io/categories/%E9%9F%B3%E4%B9%90/%E5%89%8D%E7%AB%AF/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="古典" scheme="http://aemonswift.github.io/tags/%E5%8F%A4%E5%85%B8/"/>
    
      <category term="轻音乐" scheme="http://aemonswift.github.io/tags/%E8%BD%BB%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
</feed>

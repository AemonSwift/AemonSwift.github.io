<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>长亭短亭</title>
  
  <subtitle>Man Propose, God Dispose.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://aemonswift.github.io/"/>
  <updated>2019-10-25T02:28:56.736Z</updated>
  <id>http://aemonswift.github.io/</id>
  
  <author>
    <name>AemonSwift</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>路径规划——Floyd</title>
    <link href="http://aemonswift.github.io/2019/10/25/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E2%80%94%E2%80%94Floyd/"/>
    <id>http://aemonswift.github.io/2019/10/25/路径规划——Floyd/</id>
    <published>2019-10-25T01:22:00.000Z</published>
    <updated>2019-10-25T02:28:56.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h1><p>$\color{red}{主要用来求解：}$任意两点的最短路径。该算法采用了动态规划的思想。<br>$\color{red}{思想如下：}$A到B，可以经历中转站得来降低成本；当考虑了所有的中转站的时候，则可以得到此图在A到B的最低成本。<br>$\color{red}{适用范围：}$解决多源路径问题。</p><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ol><li>初始化边矩阵M；</li><li>从U中选取顶点k加入S中，并将此元素从U中移除；</li><li>以k为中转站，更新边矩阵M的信息；</li><li>重复步骤2和3，直到所有顶点都包含在S中。<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><img alt="无向图" data-src="https://cdn.jsdelivr.net/gh/AemonSwift/AemonSwift@latest/AemonSwift.github.io/images/directpicture.jpg" class="lozad"></li></ol><p>a. 初始化M矩阵,即经过A点的M矩阵</p><table><thead><tr><th align="center">*</th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th><th align="center">E</th><th align="center">F</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">0</td><td align="center">6</td><td align="center">3</td><td align="center">$\infty$</td><td align="center">$\infty$</td><td align="center">$\infty$</td></tr><tr><td align="center">B</td><td align="center">6</td><td align="center">0</td><td align="center">2</td><td align="center">5</td><td align="center">$\infty$</td><td align="center">$\infty$</td></tr><tr><td align="center">C</td><td align="center">3</td><td align="center">2</td><td align="center">0</td><td align="center">3</td><td align="center">4</td><td align="center">$\infty$</td></tr><tr><td align="center">D</td><td align="center">$\infty$</td><td align="center">5</td><td align="center">3</td><td align="center">0</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center">E</td><td align="center">$\infty$</td><td align="center">$\infty$</td><td align="center">4</td><td align="center">2</td><td align="center">0</td><td align="center">5</td></tr><tr><td align="center">F</td><td align="center">$\infty$</td><td align="center">$\infty$</td><td align="center">$\infty$</td><td align="center">3</td><td align="center">5</td><td align="center">0</td></tr></tbody></table><p>b. 考虑经过B点，更新M矩阵</p><table><thead><tr><th align="center">*</th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th><th align="center">E</th><th align="center">F</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">0</td><td align="center">6</td><td align="center">3</td><td align="center">11</td><td align="center">$\infty$</td><td align="center">$\infty$</td></tr><tr><td align="center">B</td><td align="center">6</td><td align="center">0</td><td align="center">2</td><td align="center">5</td><td align="center">$\infty$</td><td align="center">$\infty$</td></tr><tr><td align="center">C</td><td align="center">3</td><td align="center">2</td><td align="center">0</td><td align="center">3</td><td align="center">4</td><td align="center">$\infty$</td></tr><tr><td align="center">D</td><td align="center">11</td><td align="center">5</td><td align="center">3</td><td align="center">0</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center">E</td><td align="center">$\infty$</td><td align="center">$\infty$</td><td align="center">4</td><td align="center">2</td><td align="center">0</td><td align="center">5</td></tr><tr><td align="center">F</td><td align="center">$\infty$</td><td align="center">$\infty$</td><td align="center">$\infty$</td><td align="center">3</td><td align="center">5</td><td align="center">0</td></tr></tbody></table><p>c. 考虑经过C点，更新M矩阵</p><table><thead><tr><th align="center">*</th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th><th align="center">E</th><th align="center">F</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">0</td><td align="center">5</td><td align="center">3</td><td align="center">6</td><td align="center">7</td><td align="center">$\infty$</td></tr><tr><td align="center">B</td><td align="center">5</td><td align="center">0</td><td align="center">2</td><td align="center">5</td><td align="center">6</td><td align="center">$\infty$</td></tr><tr><td align="center">C</td><td align="center">3</td><td align="center">2</td><td align="center">0</td><td align="center">3</td><td align="center">4</td><td align="center">$\infty$</td></tr><tr><td align="center">D</td><td align="center">6</td><td align="center">5</td><td align="center">3</td><td align="center">0</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center">E</td><td align="center">7</td><td align="center">6</td><td align="center">4</td><td align="center">2</td><td align="center">0</td><td align="center">5</td></tr><tr><td align="center">F</td><td align="center">$\infty$</td><td align="center">$\infty$</td><td align="center">$\infty$</td><td align="center">3</td><td align="center">5</td><td align="center">0</td></tr></tbody></table><p>d. 考虑经过D点，更新M矩阵</p><table><thead><tr><th align="center">*</th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th><th align="center">E</th><th align="center">F</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">0</td><td align="center">5</td><td align="center">3</td><td align="center">6</td><td align="center">7</td><td align="center">9</td></tr><tr><td align="center">B</td><td align="center">5</td><td align="center">0</td><td align="center">2</td><td align="center">5</td><td align="center">6</td><td align="center">8</td></tr><tr><td align="center">C</td><td align="center">3</td><td align="center">2</td><td align="center">0</td><td align="center">3</td><td align="center">4</td><td align="center">6</td></tr><tr><td align="center">D</td><td align="center">6</td><td align="center">5</td><td align="center">3</td><td align="center">0</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center">E</td><td align="center">7</td><td align="center">6</td><td align="center">4</td><td align="center">2</td><td align="center">0</td><td align="center">5</td></tr><tr><td align="center">F</td><td align="center">9</td><td align="center">8</td><td align="center">6</td><td align="center">3</td><td align="center">5</td><td align="center">0</td></tr></tbody></table><p>e. 考虑经过E点，更新M矩阵</p><table><thead><tr><th align="center">*</th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th><th align="center">E</th><th align="center">F</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">0</td><td align="center">5</td><td align="center">3</td><td align="center">6</td><td align="center">7</td><td align="center">9</td></tr><tr><td align="center">B</td><td align="center">5</td><td align="center">0</td><td align="center">2</td><td align="center">5</td><td align="center">6</td><td align="center">8</td></tr><tr><td align="center">C</td><td align="center">3</td><td align="center">2</td><td align="center">0</td><td align="center">3</td><td align="center">4</td><td align="center">6</td></tr><tr><td align="center">D</td><td align="center">6</td><td align="center">5</td><td align="center">3</td><td align="center">0</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center">E</td><td align="center">7</td><td align="center">6</td><td align="center">4</td><td align="center">2</td><td align="center">0</td><td align="center">5</td></tr><tr><td align="center">F</td><td align="center">9</td><td align="center">8</td><td align="center">6</td><td align="center">3</td><td align="center">5</td><td align="center">0</td></tr></tbody></table><p>f. 考虑经过F点，更新M矩阵</p><table><thead><tr><th align="center">*</th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th><th align="center">E</th><th align="center">F</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">0</td><td align="center">5</td><td align="center">3</td><td align="center">6</td><td align="center">7</td><td align="center">9</td></tr><tr><td align="center">B</td><td align="center">5</td><td align="center">0</td><td align="center">2</td><td align="center">5</td><td align="center">6</td><td align="center">8</td></tr><tr><td align="center">C</td><td align="center">3</td><td align="center">2</td><td align="center">0</td><td align="center">3</td><td align="center">4</td><td align="center">6</td></tr><tr><td align="center">D</td><td align="center">6</td><td align="center">5</td><td align="center">3</td><td align="center">0</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center">E</td><td align="center">7</td><td align="center">6</td><td align="center">4</td><td align="center">2</td><td align="center">0</td><td align="center">5</td></tr><tr><td align="center">F</td><td align="center">9</td><td align="center">8</td><td align="center">6</td><td align="center">3</td><td align="center">5</td><td align="center">0</td></tr></tbody></table><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><h2 id="头文件描述"><a href="#头文件描述" class="headerlink" title="头文件描述"></a>头文件描述</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pragma once</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stringstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphDG</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> pointSum;</span><br><span class="line"><span class="keyword">int</span> edge;</span><br><span class="line"><span class="keyword">int</span> **adjacentMat；</span><br><span class="line"><span class="keyword">int</span> **dis;</span><br><span class="line"><span class="keyword">int</span> **path;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">intToString</span><span class="params">(<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkEdgeValue</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> weight)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">GraphDG(<span class="keyword">int</span> pointSum,<span class="keyword">int</span> edge);</span><br><span class="line">~GraphDG();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createGraph</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMinPath</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"Floyd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> INT_MAX=<span class="number">2</span>^<span class="number">32</span><span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">GraphDG::GraphDG(<span class="keyword">int</span> pointSum,<span class="keyword">int</span> edge)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;pointSum=pointSum;</span><br><span class="line"><span class="keyword">this</span>-&gt;edge=edge;</span><br><span class="line"><span class="keyword">this</span>-&gt;adjacentMat=<span class="keyword">new</span> <span class="keyword">int</span>*[<span class="keyword">this</span>-&gt;pointSum];</span><br><span class="line"><span class="keyword">this</span>-&gt;dis=<span class="keyword">new</span> <span class="keyword">int</span>*[<span class="keyword">this</span>-&gt;pointSum];</span><br><span class="line"><span class="keyword">this</span>-&gt;path=<span class="keyword">new</span> <span class="keyword">int</span>*[<span class="keyword">this</span>-&gt;pointSum];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>-&gt;pointSum;i++)&#123;</span><br><span class="line">adjacentMat[i]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>-&gt;pointSum];</span><br><span class="line">dis[i]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>-&gt;pointSum];</span><br><span class="line">path[i]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>-&gt;pointSum];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="keyword">this</span>-&gt;pointSum;j++)&#123;</span><br><span class="line">adjacentMat[i][j]=INT_MAX;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GraphDG::~GraphDG()&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>-&gt;pointSum;i++)&#123;</span><br><span class="line"><span class="keyword">delete</span> adjacentMat[i];</span><br><span class="line"><span class="keyword">delete</span> dis[i];</span><br><span class="line"><span class="keyword">delete</span> path[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> adjacentMat;</span><br><span class="line"><span class="keyword">delete</span> dis;</span><br><span class="line"><span class="keyword">delete</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> GraphDG::checkEdgeValue(<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> weight)&#123;</span><br><span class="line"><span class="keyword">if</span> (start&lt;<span class="number">1</span>||end&lt;<span class="number">1</span>||start&gt;end||end&gt;pointSum||weight&lt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GraphDG::createGraph(<span class="keyword">int</span> kind)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入每条边的起点和终点（顶点编号从1开始）以及其权重"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> start,end,weight;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>-&gt;edge;i++&gt;)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;start&gt;&gt;end&gt;&gt;weight;</span><br><span class="line"><span class="keyword">while</span>(!<span class="keyword">this</span>-&gt;checkEdgeValue(start,end,weight))&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入的边的信息不合法，请重新输入"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; start &gt;&gt; end &gt;&gt; weight;</span><br><span class="line">&#125;</span><br><span class="line">adjacentMat[start<span class="number">-1</span>][end<span class="number">-1</span>]=weight;</span><br><span class="line"><span class="comment">//变成无向图</span></span><br><span class="line"><span class="keyword">if</span> (kind==<span class="number">2</span>)&#123;</span><br><span class="line">adjacentMat[end<span class="number">-1</span>][start<span class="number">-1</span>]=weight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GraphDG::print()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"图的邻接矩阵为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row=<span class="number">0</span>;row&lt;<span class="keyword">this</span>-&gt;pointSum;row++&gt;)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;<span class="keyword">this</span>-&gt;pointSum;col++)&#123;</span><br><span class="line"><span class="keyword">if</span> adjacentMat[row][col]==INT_MAX&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"i "</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;adjacentMat[row][col]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//思想在于：A到B，可以经历中转站得来降低成本；当考虑了所有的中转站的时候，则可以得到此图在A到B的最低成本。——动态规划思想</span></span><br><span class="line"><span class="keyword">void</span> GraphDG::Floyd()&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row=<span class="number">0</span>;row&lt;<span class="keyword">this</span>-&gt;pointSum;row++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;<span class="keyword">this</span>-&gt;pointSum;col++)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;dis[row][col]=<span class="keyword">this</span>-&gt;adjacentMat[row][col];</span><br><span class="line"><span class="keyword">this</span>-&gt;path[row][col]=col;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> temp =<span class="number">0</span>;temp&lt;<span class="keyword">this</span>-&gt;pointSum;temp++)&#123; <span class="comment">//temp为中转站</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>-&gt;pointSum;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="keyword">this</span>-&gt;pointSum;j++)&#123;</span><br><span class="line">select=(dis[row][temp] == INT_MAX || dis[temp][col] == INT_MAX) ? INT_MAX : (dis[row][temp] + dis[temp][col]);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>-&gt;dis[i][j]&gt;select)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;dis[i][j]=select;</span><br><span class="line"><span class="keyword">this</span>-&gt;path[i][j]=<span class="keyword">this</span>-&gt;path[i][temp];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GraphDG::printMinPath()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"各个顶点对的最短路径："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row=<span class="number">0</span>;row&lt;<span class="keyword">this</span>-&gt;pointSum;row++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;<span class="keyword">this</span>-&gt;pointSum;col++)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"v"</span>&lt;&lt;intToString(row+<span class="number">1</span>)&lt;&lt;<span class="string">"--"</span>&lt;&lt;<span class="string">"v"</span>&lt;&lt;intToString(col+<span class="number">1</span>)&lt;&lt;<span class="string">"weight:"</span></span><br><span class="line">&lt;&lt;<span class="keyword">this</span>-&gt;dis[row][col]&lt;&lt;<span class="string">"path:"</span>&lt;&lt;<span class="string">"v"</span>&lt;&lt;intToString(row+<span class="number">1</span>);</span><br><span class="line">temp=path[row][col];</span><br><span class="line"><span class="keyword">while</span>(temp!=col)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"--&gt;"</span>&lt;&lt;<span class="string">"v"</span>&lt;&lt;intToString(temp+<span class="number">1</span>);</span><br><span class="line">temp=path[temp][col];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"--&gt;"</span>&lt;&lt;<span class="string">"v"</span>&lt;&lt;intToString(col+<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> GraphDG::intToString(<span class="keyword">int</span> target)&#123;</span><br><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line">ss&lt;&lt;target;</span><br><span class="line"><span class="keyword">return</span> ss&gt;&gt;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试函数"><a href="#测试函数" class="headerlink" title="测试函数"></a>测试函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Floyd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> pointSum,<span class="keyword">int</span> edge)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pointSum&lt;=<span class="number">1</span>||edge&lt;=<span class="number">0</span>||(pointSum<span class="number">-1</span>)*pointSum&lt;edge)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pointSum,edge,kind;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入图的种类：1代表有向图，2代表无向图"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;kind;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (kind==<span class="number">1</span>||kind==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入的图的种类编号不合法，请重新输入：1代表有向图，2代表无向图"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; kind;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入图的顶点个数和边的条数："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; pointSum &gt;&gt; edge;</span><br><span class="line">    <span class="keyword">while</span> (!check(pointSum, edge)) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入的数值不合法，请重新输入"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; pointSum &gt;&gt; edge;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">GraphDG <span class="title">graph</span><span class="params">(pointSum,edge)</span></span>;</span><br><span class="line">    graph.createGraph(kind);</span><br><span class="line">    graph.print();</span><br><span class="line">    graph.Floy();</span><br><span class="line">    graph.printMinPath();</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入参数</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 7 12</span></span><br><span class="line"><span class="comment">// 1 2 12</span></span><br><span class="line"><span class="comment">// 1 6 16</span></span><br><span class="line"><span class="comment">// 1 7 14</span></span><br><span class="line"><span class="comment">// 2 3 10</span></span><br><span class="line"><span class="comment">// 2 6 7</span></span><br><span class="line"><span class="comment">// 3 4 3</span></span><br><span class="line"><span class="comment">// 3 5 5</span></span><br><span class="line"><span class="comment">// 3 6 6</span></span><br><span class="line"><span class="comment">// 4 5 4</span></span><br><span class="line"><span class="comment">// 5 6 2</span></span><br><span class="line"><span class="comment">// 5 7 8</span></span><br><span class="line"><span class="comment">// 6 7 9</span></span><br></pre></td></tr></table></figure><h1 id="算法缺陷"><a href="#算法缺陷" class="headerlink" title="算法缺陷"></a>算法缺陷</h1><p>可以求有负权值的边，但是不能有负回路。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;思想&quot;&gt;&lt;a href=&quot;#思想&quot; class=&quot;headerlink&quot; title=&quot;思想&quot;&gt;&lt;/a&gt;思想&lt;/h1&gt;&lt;p&gt;$\color{red}{主要用来求解：}$任意两点的最短路径。该算法采用了动态规划的思想。&lt;br&gt;$\color{red}{思想如下：}$
      
    
    </summary>
    
    
      <category term="算法" scheme="http://aemonswift.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="路径规划" scheme="http://aemonswift.github.io/categories/%E7%AE%97%E6%B3%95/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"/>
    
    
      <category term="算法" scheme="http://aemonswift.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="路径规划" scheme="http://aemonswift.github.io/tags/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>路径规划——Dijkstra</title>
    <link href="http://aemonswift.github.io/2019/10/24/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E2%80%94%E2%80%94Dijkstra/"/>
    <id>http://aemonswift.github.io/2019/10/24/路径规划——Dijkstra/</id>
    <published>2019-10-24T07:03:06.000Z</published>
    <updated>2019-10-25T01:45:09.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h1><p>$\color{red}{主要用来求解：}$从起始点到其他所有点的最短路径。该算法采用了贪心的思想。<br>$\color{red}{思想如下：}$A到B可以有多个中转站集合U，如何选择中转站？本算法选择最低的成本的中转站，即将C1加入到需要走的中转站集合S中，在目前集合S情况下，得到了A到所有各站的成本，在此成本基础上选择最低的成本加入到需要走的中转站集合S中，重复上述操作。<br>$\color{red}{适用范围：}$解决单源路径问题。</p><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ol><li>初始化时，S只含有源节点；</li><li>从U中选取一个距离v最小的顶点k加入S中（该选定的距离就是v到k的最短路径长度），并将此元素从U中移除；</li><li>以k为新考虑的中间点，修改U中各顶点的距离；若从源节点v到顶点u的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值是顶点k的距离加上k到u的距离；</li><li>重复步骤2和3，直到所有顶点都包含在S中。<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><img alt="无向图" data-src="https://cdn.jsdelivr.net/gh/AemonSwift/AemonSwift@latest/AemonSwift.github.io/images/directpicture.jpg" class="lozad"><br>从A开始出发，到其他所有点的最短距离和路径<table><thead><tr><th align="center">步骤</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">初始化距离$dis=[0,6,3,\infty,\infty,\infty,\infty]$，此时S={A},U={B,C,D,E,F}</td></tr><tr><td align="center">2</td><td align="center">排除S中的点，寻找dis中最小距离的点C,此时距离为$dis=[0,5,3,6,7,\infty]$，此时S={A,C},U={B,D,E,F}</td></tr><tr><td align="center">3</td><td align="center">排除S中的点，寻找dis中最小距离的点B，此时距离变为$dis=[0,5,3,6,7,\infty]$，此时S={A,C,B},U={D,E,F}</td></tr><tr><td align="center">4</td><td align="center">排除S中的点，寻找dis中最小距离的点D，此时距离变为$dis=[0,5,3,6,7,9]$，此时S={A,C,B,D},U={E,F}</td></tr><tr><td align="center">5</td><td align="center">排除S中的点，寻找dis中最小距离的点E，此时距离变为$dis=[0,5,3,6,7,9]$，此时S={A,C,B,D,E},U={F}</td></tr><tr><td align="center">6</td><td align="center">排除S中的点，寻找dis中最小距离的点F，此时距离变为$dis=[0,5,3,6,7,9]$，此时S={A,C,B,D,F},U={}</td></tr></tbody></table></li></ol><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><h2 id="头文件描述"><a href="#头文件描述" class="headerlink" title="头文件描述"></a>头文件描述</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dijkstra.h</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">pragma</span> once <span class="comment">//pragma once是一个比较常用的C/C++声明，只要在头文件的最开始加入这条杂注，就能够保证头文件只被编译一次。</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dis</span>&#123;</span></span><br><span class="line"><span class="built_in">string</span> path;</span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">bool</span> visit;</span><br><span class="line"><span class="keyword">int</span> prePoint; <span class="comment">//记录到当前节点的上一个节点是谁</span></span><br><span class="line">Dis()&#123;</span><br><span class="line">visit=<span class="literal">false</span>;</span><br><span class="line">value=<span class="number">0</span>;</span><br><span class="line">path=<span class="string">""</span>;</span><br><span class="line">minPath=<span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphDG</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> pointNum;</span><br><span class="line"><span class="keyword">int</span> edge;</span><br><span class="line"><span class="keyword">int</span> **adjacentMat；</span><br><span class="line">Dis*dis;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">intToString</span><span class="params">(<span class="keyword">int</span> target)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkEdgeValue</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> weight)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">GraphDG(<span class="keyword">int</span> pointNum,<span class="keyword">int</span> edge);</span><br><span class="line">~GraphDG();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createGraph</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resloveMinPath</span><span class="params">(<span class="keyword">int</span> begin)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSearchPath</span><span class="params">(<span class="keyword">int</span> begin)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMinPath</span><span class="params">(<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"Dijkstra.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> INT_MAX=<span class="number">2</span>^<span class="number">31</span><span class="number">-1</span>;</span><br><span class="line">GraphDG::GraphDG(<span class="keyword">int</span> pointNum,<span class="keyword">int</span> edge)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;pointNum=pointNum;</span><br><span class="line"><span class="keyword">this</span>-&gt;edge=edge;</span><br><span class="line">adjacentMat=<span class="keyword">new</span> <span class="keyword">int</span>* [<span class="keyword">this</span>-&gt;pointNum];</span><br><span class="line">dis=<span class="keyword">new</span> Dis[<span class="keyword">this</span>-&gt;pointNum];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>-&gt;pointNum;i++)&#123;</span><br><span class="line">adjacentMat=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>-&gt;pointNum];</span><br><span class="line"><span class="function"><span class="keyword">for</span> <span class="title">int</span><span class="params">(j=<span class="number">0</span>;j&lt;<span class="keyword">this</span>-&gt;pointNum;j++)</span></span>&#123;</span><br><span class="line">adjacentMat[i][j]=INT_MAX; <span class="comment">//开始赋值无穷大</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GraphDG::~GraphDG() &#123;</span><br><span class="line"><span class="keyword">delete</span> dis;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>-&gt;pointNum;i++)&#123;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;adjacentMat[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;adjacentMat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> GraphDG::checkEdgeValue(<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> weight)&#123;</span><br><span class="line"><span class="keyword">if</span> (start&lt;<span class="number">1</span>||end&lt;<span class="number">1</span>||start&gt;<span class="keyword">this</span>-&gt;pointNum||end&gt;<span class="keyword">this</span>-&gt;pointNum||weight&lt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GraphDG::createGraph()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入每条边的起点和终点（顶点编号从1开始）以及其权重"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> start,end,weight,count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(count!=<span class="keyword">this</span>-&gt;edge)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;start&gt;&gt;end&gt;&gt;weight;</span><br><span class="line"><span class="keyword">while</span>(!<span class="keyword">this</span>-&gt;checkEdgeValue(start,end,weight))&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入的边的信息不合法，请重新输入"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; start &gt;&gt; end &gt;&gt; weight;</span><br><span class="line">&#125;</span><br><span class="line">adjacentMat[start<span class="number">-1</span>][end<span class="number">-1</span>]=weight;</span><br><span class="line"><span class="comment">// adjacentMat[end-1][start-1]=weight 加上这句为无向边</span></span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GraphDG::print(<span class="keyword">int</span> begin)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"图的邻接矩阵为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row=<span class="number">0</span>;row&lt;<span class="keyword">this</span>-&gt;pointNum;col++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;<span class="keyword">this</span>-&gt;pointNum;i++;col++)&#123;</span><br><span class="line"><span class="keyword">if</span> (adjacentMat[row][col]==INT_MAX)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"infinity"</span>；</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;adjacentMat[row][col];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GraphDG::printSearchPath(<span class="keyword">int</span> begin)&#123;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line">str=<span class="string">"v"</span>+intToString(begin);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"以"</span>&lt;&lt;str&lt;&lt;<span class="string">"为起点的图的最短路径为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i!=<span class="keyword">this</span>-&gt;pointNum;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[i].value!=INT_MAX)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dis[i].path &lt;&lt; <span class="string">"="</span> &lt;&lt; dis[i].value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dis[i].path &lt;&lt; <span class="string">"是无最短路径的"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GraphDG::printMinpath(<span class="keyword">int</span> begin,<span class="keyword">int</span> end)&#123;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">int</span> prePoint=dis[end].prePoint;</span><br><span class="line"><span class="keyword">while</span>(prePoint&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">proPoint=dis[prePoint].prePoint;</span><br><span class="line"><span class="keyword">if</span> (prePoint==proPoint)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">str=intToString(prePoint+<span class="number">1</span>)+<span class="string">" "</span>+str;</span><br><span class="line">prePoint=proPoint;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GraphDG::Dijkstra(<span class="keyword">int</span> begin)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>-&gt;pointNum;i++)&#123;</span><br><span class="line">dis[i].path=<span class="string">"v"</span>+intToString(begin)+<span class="string">"--&gt;v"</span>+intToString(i+<span class="number">1</span>);</span><br><span class="line">dis[i].value=adjacentMat[begin<span class="number">-1</span>][i];</span><br><span class="line">dis[i].prePoint=begin;</span><br><span class="line">&#125;</span><br><span class="line">dis[begin<span class="number">-1</span>].value=<span class="number">0</span>;</span><br><span class="line">dis[begin<span class="number">-1</span>].visit=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count=<span class="number">1</span>;count&lt;<span class="keyword">this</span>-&gt;pointNum;count++)&#123;</span><br><span class="line"><span class="comment">//找加入的最小值对应的下标</span></span><br><span class="line"><span class="keyword">int</span> temp=<span class="number">0</span>,min=INT_MAX;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>-&gt;pointNum;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!dis[i].visit&amp;&amp;dis[i].value&lt;INT_MAX)&#123;</span><br><span class="line">min=dis[i].value;</span><br><span class="line">temp=i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dis[temp].visit=<span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 计算剩余点的最短路径</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>-&gt;pointNum;i++&gt;)&#123;</span><br><span class="line"><span class="comment">//注意这里的条件adjacentMat[temp][i]!=INT_MAX必须加，不然会出现溢出，从而造成程序异常</span></span><br><span class="line"><span class="keyword">if</span>(!dis[i].visit&amp;&amp;adjacentMat[temp][i]!=INT_MAX&amp;&amp;dis[temp].value+adjacentMat[temp][i]&lt;dis[i].value)&#123;</span><br><span class="line">dis[i].value=dis[temp].value+adjacentMat[temp][i];</span><br><span class="line">dis[i].path=dis[temp].path+<span class="string">"--&gt;v"</span>+intToString(i+<span class="number">1</span>);</span><br><span class="line">dis[i].prePoint=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> GraphDG::intToString(<span class="keyword">int</span> target)&#123;</span><br><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line">ss&lt;&lt;target;</span><br><span class="line"><span class="keyword">return</span> ss&gt;&gt;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试函数"><a href="#测试函数" class="headerlink" title="测试函数"></a>测试函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Dijkstra.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> pointNum,<span class="keyword">int</span> edge)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pointNum&lt;=<span class="number">1</span>||edge&lt;=<span class="number">0</span>||(pointNum<span class="number">-1</span>)*pointNum/<span class="number">2</span>&lt;edge)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pointNum,edge;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入图的顶点个数和边的条数："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; pointNum &gt;&gt; edge;</span><br><span class="line">    <span class="keyword">while</span> (!check(vexnum, edge)) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入的数值不合法，请重新输入"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; pointNum &gt;&gt; edge;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">GraphDG <span class="title">grpah</span><span class="params">(pointNum,edge)</span></span>;</span><br><span class="line">    graph.createGraph();</span><br><span class="line">    graph.print();</span><br><span class="line">    graph.Dijkstra();</span><br><span class="line">    graph.printSearchPath();</span><br><span class="line">    graph.printMinPath();</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输入参数</span></span><br><span class="line"><span class="comment">// 6 8</span></span><br><span class="line"><span class="comment">// 1 3 10</span></span><br><span class="line"><span class="comment">// 1 5 30</span></span><br><span class="line"><span class="comment">// 1 6 100</span></span><br><span class="line"><span class="comment">// 2 3 5</span></span><br><span class="line"><span class="comment">// 3 4 50</span></span><br><span class="line"><span class="comment">// 4 6 10</span></span><br><span class="line"><span class="comment">// 5 6 60</span></span><br><span class="line"><span class="comment">// 5 4 20</span></span><br></pre></td></tr></table></figure><h1 id="算法缺陷"><a href="#算法缺陷" class="headerlink" title="算法缺陷"></a>算法缺陷</h1><p>若权重为负边的时候，此算法失效。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;思想&quot;&gt;&lt;a href=&quot;#思想&quot; class=&quot;headerlink&quot; title=&quot;思想&quot;&gt;&lt;/a&gt;思想&lt;/h1&gt;&lt;p&gt;$\color{red}{主要用来求解：}$从起始点到其他所有点的最短路径。该算法采用了贪心的思想。&lt;br&gt;$\color{red}{思想如
      
    
    </summary>
    
    
      <category term="算法" scheme="http://aemonswift.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="路径规划" scheme="http://aemonswift.github.io/categories/%E7%AE%97%E6%B3%95/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"/>
    
    
      <category term="算法" scheme="http://aemonswift.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="路径规划" scheme="http://aemonswift.github.io/tags/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>冒泡算法及其优化</title>
    <link href="http://aemonswift.github.io/2019/10/23/%E5%86%92%E6%B3%A1%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"/>
    <id>http://aemonswift.github.io/2019/10/23/冒泡算法及其优化/</id>
    <published>2019-10-23T07:01:32.000Z</published>
    <updated>2019-10-24T02:03:06.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h1><p>给你一个数列，对相邻的两个个数进行比较，让大数下沉，或较小的数字进行上浮。</p><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><h2 id="一般实现方法"><a href="#一般实现方法" class="headerlink" title="一般实现方法"></a>一般实现方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len-i<span class="number">-1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                tmp=arr[j];</span><br><span class="line">                arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述算法实现的缺陷：若排到一定时候，当数列再也没有发生交换（即顺序已经排好），但仍然进行循环。</p><h2 id="优化1——引入有序标记"><a href="#优化1——引入有序标记" class="headerlink" title="优化1——引入有序标记"></a>优化1——引入有序标记</h2><p>针对一般实现方法，引入一个标记 <code>flag</code>，来判断是否发生来交换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len-i<span class="number">-1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                tmp=arr[j];</span><br><span class="line">                arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>]=tmp;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述算法实现仍然有着缺陷：若排到一定时候，后面部分都有顺序，而只是前面部分没有顺序，会进行不必要的循环次数。</p><h2 id="优化2——引入位置标记"><a href="#优化2——引入位置标记" class="headerlink" title="优化2——引入位置标记"></a>优化2——引入位置标记</h2><p>针对优化1实现的方法，引入一个位置标记<code>pos</code>，来记录从哪个位置开始时，后面的数据都有顺序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=<span class="number">0</span>,flag=<span class="number">0</span>,pos=<span class="number">0</span>,k=len<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        pos=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                tmp=arr[j];</span><br><span class="line">                arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>]=tmp;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">                pos=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        k=pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还没有方法来继续提高效率？</p><h2 id="优化3——鸡尾酒排序"><a href="#优化3——鸡尾酒排序" class="headerlink" title="优化3——鸡尾酒排序"></a>优化3——鸡尾酒排序</h2><p>回归到冒泡思想：给你一个数列，对相邻的两个个数进行比较，让大数下沉，或较小的数字进行上浮。若一次排序让大数和小数一并都找到，这样大大缩小了第一层的循环次数。——称为鸡尾酒排序。<br><code>pos</code>标记从哪个位置开始时，后面的数据都有顺序。<br><code>prepos</code>标记从哪个位置开始时，前面的数据都有顺序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=<span class="number">0</span>,flag=<span class="number">0</span>,pos=<span class="number">0</span>,k=len<span class="number">-1</span>,prepos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        pos=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;k;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                tmp=arr[j];</span><br><span class="line">                arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>]=tmp;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">                pos=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        k=pos;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=k;j&gt;i;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j]&lt;arr[j<span class="number">-1</span>])&#123;</span><br><span class="line">                tmp=arr[j];</span><br><span class="line">                arr[j]=arr[j<span class="number">-1</span>];</span><br><span class="line">                arr[j<span class="number">-1</span>]=tmp;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">                prepos=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i=prepos<span class="number">-1</span>; <span class="comment">//由于i++操作，故需要进行减1操作，才能回到从哪个位置开始，前面都有序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;思想&quot;&gt;&lt;a href=&quot;#思想&quot; class=&quot;headerlink&quot; title=&quot;思想&quot;&gt;&lt;/a&gt;思想&lt;/h1&gt;&lt;p&gt;给你一个数列，对相邻的两个个数进行比较，让大数下沉，或较小的数字进行上浮。&lt;/p&gt;
&lt;h1 id=&quot;算法实现&quot;&gt;&lt;a href=&quot;#算法实现
      
    
    </summary>
    
    
      <category term="算法" scheme="http://aemonswift.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://aemonswift.github.io/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="算法" scheme="http://aemonswift.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>hello</title>
    <link href="http://aemonswift.github.io/2019/10/21/hello/"/>
    <id>http://aemonswift.github.io/2019/10/21/hello/</id>
    <published>2019-10-21T12:01:35.000Z</published>
    <updated>2019-10-22T00:59:53.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><h2 id="问题为什么重要"><a href="#问题为什么重要" class="headerlink" title="问题为什么重要"></a>问题为什么重要</h2><h2 id="问题目前解决方案有哪些"><a href="#问题目前解决方案有哪些" class="headerlink" title="问题目前解决方案有哪些"></a>问题目前解决方案有哪些</h2><h2 id="问题的难点是什么"><a href="#问题的难点是什么" class="headerlink" title="问题的难点是什么"></a>问题的难点是什么</h2><h2 id="你的创新点是什么"><a href="#你的创新点是什么" class="headerlink" title="你的创新点是什么"></a>你的创新点是什么</h2><h1 id="问题求解"><a href="#问题求解" class="headerlink" title="问题求解"></a>问题求解</h1><h2 id="问题数学描述"><a href="#问题数学描述" class="headerlink" title="问题数学描述"></a>问题数学描述</h2><p>问世间，何许人也！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;h2 id=&quot;问题为什么重要&quot;&gt;&lt;a href=&quot;#问题为什么重要&quot; class=&quot;headerlink&quot; title=&quot;问题为
      
    
    </summary>
    
    
      <category term="音乐" scheme="http://aemonswift.github.io/categories/%E9%9F%B3%E4%B9%90/"/>
    
      <category term="前端" scheme="http://aemonswift.github.io/categories/%E9%9F%B3%E4%B9%90/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="后端" scheme="http://aemonswift.github.io/categories/%E9%9F%B3%E4%B9%90/%E5%89%8D%E7%AB%AF/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="古典" scheme="http://aemonswift.github.io/tags/%E5%8F%A4%E5%85%B8/"/>
    
      <category term="轻音乐" scheme="http://aemonswift.github.io/tags/%E8%BD%BB%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://aemonswift.github.io/2019/10/21/hello-world/"/>
    <id>http://aemonswift.github.io/2019/10/21/hello-world/</id>
    <published>2019-10-21T00:53:07.676Z</published>
    <updated>2019-10-21T00:53:07.676Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>

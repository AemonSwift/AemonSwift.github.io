{"meta":{"title":"长亭短亭","subtitle":"Man Propose, God Dispose.","description":null,"author":"AemonSwift","url":"http://aemonswift.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-10-24T02:01:31.000Z","updated":"2019-10-24T02:08:24.653Z","comments":true,"path":"categories/index.html","permalink":"http://aemonswift.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-10-24T02:01:12.000Z","updated":"2019-10-24T02:08:13.934Z","comments":true,"path":"tags/index.html","permalink":"http://aemonswift.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"路径规划——Dijkstra","slug":"路径规划——Dijkstra","date":"2019-10-24T07:03:06.000Z","updated":"2019-10-24T11:49:12.586Z","comments":true,"path":"2019/10/24/路径规划——Dijkstra/","link":"","permalink":"http://aemonswift.github.io/2019/10/24/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E2%80%94%E2%80%94Dijkstra/","excerpt":"","text":"思想主要用来求解：从起始点到其他所有点的最短路径。该算法采用了贪心的思想。思想如下：A到B可以有多个中转站集合U，如何选择中转站？本算法选择最低的成本的中转站，即将C1加入到需要走的中转站集合S中，在目前集合S情况下，得到了A到所有各站的成本，在此成本基础上选择最低的成本加入到需要走的中转站集合S中，重复上述操作。 算法步骤 初始化时，S只含有源节点； 从U中选取一个距离v最小的顶点k加入S中（该选定的距离就是v到k的最短路径长度）； 以k为新考虑的中间点，修改U中各顶点的距离；若从源节点v到顶点u的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值是顶点k的距离加上k到u的距离； 重复步骤2和3，直到所有顶点都包含在S中。例子从A开始出发，到其他所有点的最短距离和路径 步骤 描述 1 初始化距离$dis=[0,6,3,\\infty,\\infty,\\infty,\\infty]$，此时S={A},U={B,C,D,E,F} 2 排除S中的点，寻找dis中最小距离的点C,此时距离为$dis=[0,5,3,6,7,\\infty]$，此时S={A,C},U={B,D,E,F} 3 排除S中的点，寻找dis中最小距离的点B，此时距离变为$dis=[0,5,3,6,7,\\infty]$，此时S={A,C,B},U={D,E,F} 4 排除S中的点，寻找dis中最小距离的点D，此时距离变为$dis=[0,5,3,6,7,9]$，此时S={A,C,B,D},U={E,F} 5 排除S中的点，寻找dis中最小距离的点E，此时距离变为$dis=[0,5,3,6,7,9]$，此时S={A,C,B,D,E},U={F} 6 排除S中的点，寻找dis中最小距离的点F，此时距离变为$dis=[0,5,3,6,7,9]$，此时S={A,C,B,D,F},U={} 算法实现头文件描述1234567891011121314151617181920212223242526272829303132333435363738// Dijkstra.h# pragma once //pragma once是一个比较常用的C/C++声明，只要在头文件的最开始加入这条杂注，就能够保证头文件只被编译一次。# include &lt;iostream&gt;# include &lt;string&gt;#include &lt;sstream&gt;using namespace std;struct Dis&#123; string path; int value; bool visit; int prePoint; //记录到当前节点的上一个节点是谁 Dis()&#123; visit=false; value=0; path=\"\"; minPath=nullptr; &#125;&#125;;class GraphDG&#123;private: int pointNum; int edge; int **adjacentMat； Dis*dis; string intToString(int target); bool checkEdgeValue(int start,int end,int weight);public: GraphDG(int pointNum,int edge); ~GraphDG(); void createGraph(); void print(); void resloveMinPath(int begin); void printSearchPath(int begin); void printMinPath(int begin,int end);&#125;; 功能实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125# include \"Dijkstra.h\"const INT_MAX=2^31-1;GraphDG::GraphDG(int pointNum,int edge)&#123; this-&gt;pointNum=pointNum; this-&gt;edge=edge; adjacentMat=new int* [this-&gt;pointNum]; dis=new Dis[this-&gt;pointNum]; for(int i=0;i&lt;this-&gt;pointNum;i++)&#123; adjacentMat=new int[this-&gt;pointNum]; for int(j=0;j&lt;this-&gt;pointNum;j++)&#123; adjacentMat[i][j]=INT_MAX; //开始赋值无穷大 &#125; &#125;&#125;GraphDG::~GraphDG() &#123; delete dis; for (int i=0;i&lt;this-&gt;pointNum;i++)&#123; delete this-&gt;adjacentMat[i]; &#125; delete this-&gt;adjacentMat;&#125;bool GraphDG::checkEdgeValue(int start,int end,int weight)&#123; if (start&lt;1||end&lt;1||start&gt;this-&gt;pointNum||end&gt;this-&gt;pointNum||weight&lt;0)&#123; return false; &#125; return true;&#125;void GraphDG::createGraph()&#123; cout &lt;&lt; \"请输入每条边的起点和终点（顶点编号从1开始）以及其权重\" &lt;&lt; endl; int start,end,weight,count=0; while(count!=this-&gt;edge)&#123; cin&gt;&gt;start&gt;&gt;end&gt;&gt;weight; while(!this-&gt;checkEdgeValue(start,end,weight))&#123; cout &lt;&lt; \"输入的边的信息不合法，请重新输入\" &lt;&lt; endl; cin &gt;&gt; start &gt;&gt; end &gt;&gt; weight; &#125; adjacentMat[start-1][end-1]=weight; // adjacentMat[end-1][start-1]=weight 加上这句为无向边 count++; &#125;&#125;void GraphDG::print(int begin)&#123; cout &lt;&lt; \"图的邻接矩阵为：\" &lt;&lt; endl; for (int row=0;row&lt;this-&gt;pointNum;col++)&#123; for(int col=0;col&lt;this-&gt;pointNum;i++;col++)&#123; if (adjacentMat[row][col]==INT_MAX)&#123; cout&lt;&lt;\"infinity\"； &#125;else&#123; cout&lt;&lt;adjacentMat[row][col]; &#125; &#125; cout&lt;&lt;endl; &#125; cout&lt;&lt;endl;&#125;void GraphDG::printSearchPath(int begin)&#123; string str; str=\"v\"+intToString(begin); cout &lt;&lt; \"以\"&lt;&lt;str&lt;&lt;\"为起点的图的最短路径为：\" &lt;&lt; endl; for (int i=0;i!=this-&gt;pointNum;i++)&#123; if(dis[i].value!=INT_MAX)&#123; cout &lt;&lt; dis[i].path &lt;&lt; \"=\" &lt;&lt; dis[i].value &lt;&lt; endl; &#125;else&#123; cout &lt;&lt; dis[i].path &lt;&lt; \"是无最短路径的\" &lt;&lt; endl; &#125; &#125;&#125;void GraphDG::printMinpath(int begin,int end)&#123; string str; int prePoint=dis[end].prePoint; while(prePoint&gt;=0)&#123; proPoint=dis[prePoint].prePoint; if (prePoint==proPoint)&#123; break; &#125; str=intToString(prePoint+1)+\" \"+str; prePoint=proPoint; &#125; cout&lt;&lt;str;&#125;void GraphDG::Dijkstra(int begin)&#123; for (int i=0;i&lt;this-&gt;pointNum;i++)&#123; dis[i].path=\"v\"+intToString(begin)+\"--&gt;v\"+intToString(i+1); dis[i].value=adjacentMat[begin-1][i]; dis[i].prePoint=begin; &#125; dis[begin-1].value=0; dis[begin-1].visit=true; for (int count=1;count&lt;this-&gt;pointNum;count++)&#123; //找加入的最小值对应的下标 int temp=0,min=INT_MAX; for (int i=0;i&lt;this-&gt;pointNum;i++)&#123; if(!dis[i].visit&amp;&amp;dis[i].value&lt;INT_MAX)&#123; min=dis[i].value; temp=i &#125; &#125; dis[temp].visit=true; // 计算剩余点的最短路径 for (int i=0;i&lt;this-&gt;pointNum;i++&gt;)&#123; //注意这里的条件adjacentMat[temp][i]!=INT_MAX必须加，不然会出现溢出，从而造成程序异常 if(!dis[i].visit&amp;&amp;adjacentMat[temp][i]!=INT_MAX&amp;&amp;dis[temp].value+adjacentMat[temp][i]&lt;dis[i].value)&#123; dis[i].value=dis[temp].value+adjacentMat[temp][i]; dis[i].path=dis[temp].path+\"--&gt;v\"+intToString(i+1); dis[i].prePoint=temp; &#125; &#125; &#125;&#125;string GraphDG::intToString(int target)&#123; stringstream ss; ss&lt;&lt;target; return ss&gt;&gt;; &#125; 测试函数123456789101112131415161718192021222324252627282930313233343536#include \"Dijkstra.h\"bool check(int pointNum,int edge)&#123; if(pointNum&lt;=1||edge&lt;=0||(pointNum-1)*pointNum/2&lt;edge)&#123; return false; &#125; return true;&#125;int main()&#123; int pointNum,edge; cout &lt;&lt; \"输入图的顶点个数和边的条数：\" &lt;&lt; endl; cin &gt;&gt; pointNum &gt;&gt; edge; while (!check(vexnum, edge)) &#123; cout &lt;&lt; \"输入的数值不合法，请重新输入\" &lt;&lt; endl; cin &gt;&gt; pointNum &gt;&gt; edge; &#125; GraphDG grpah(pointNum,edge); graph.createGraph(); graph.print(); graph.Dijkstra(); graph.printSearchPath(); graph.printMinPath(); system(\"pause\"); return 0;&#125;//输入参数// 6 8// 1 3 10// 1 5 30// 1 6 100// 2 3 5// 3 4 50// 4 6 10// 5 6 60// 5 4 20 算法缺陷若权重为负边的时候，此算法失效。","categories":[{"name":"算法","slug":"算法","permalink":"http://aemonswift.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"路径规划","slug":"算法/路径规划","permalink":"http://aemonswift.github.io/categories/%E7%AE%97%E6%B3%95/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://aemonswift.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"路径规划","slug":"路径规划","permalink":"http://aemonswift.github.io/tags/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"}]},{"title":"冒泡算法及其优化","slug":"冒泡算法及其优化","date":"2019-10-23T07:01:32.000Z","updated":"2019-10-24T02:03:06.983Z","comments":true,"path":"2019/10/23/冒泡算法及其优化/","link":"","permalink":"http://aemonswift.github.io/2019/10/23/%E5%86%92%E6%B3%A1%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/","excerpt":"","text":"思想给你一个数列，对相邻的两个个数进行比较，让大数下沉，或较小的数字进行上浮。 算法实现一般实现方法123456789101112void BubbleSort(int arr[],int len)&#123; int tmp=0; for (int i=0;i&lt;len;i++)&#123; for(int j=0;j&lt;len-i-1;j++)&#123; if (arr[j]&gt;arr[j+1])&#123; tmp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=tmp; &#125; &#125; &#125;&#125; 上述算法实现的缺陷：若排到一定时候，当数列再也没有发生交换（即顺序已经排好），但仍然进行循环。 优化1——\b引入有序标记针对一般实现方法，引入一个标记 flag，来判断是否发生来交换 1234567891011121314151617void BubbleSort(int arr[],int len)&#123; int tmp=0,flag=0; for (int i=0;i&lt;len;i++)&#123; flag=0; for(int j=0;j&lt;len-i-1;j++)&#123; if (arr[j]&gt;arr[j+1])&#123; tmp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=tmp; flag=1; &#125; &#125; if (flag==0)&#123; return; &#125; &#125;&#125; 上述算法实现仍然有着缺陷：若排到一定时候，后面部分都有顺序，而只是前面部分没有顺序，会进行不必要的循环次数。 优化2——引入位置标记针对优化1实现的方法，引入一个位置标记pos，来记录从哪个位置开始时，后面的数据都有顺序。 1234567891011121314151617181920void BubbleSort(int arr[],int len)&#123; int tmp=0,flag=0,pos=0,k=len-1; for (int i=0;i&lt;len;i++)&#123; flag=0; pos=0; for(int j=0;j&lt;k;j++)&#123; if (arr[j]&gt;arr[j+1])&#123; tmp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=tmp; flag=1; pos=j; &#125; &#125; if (flag==0)&#123; return; &#125; k=pos; &#125;&#125; 还没有方法来继续提高效率？ 优化3——鸡尾酒排序回归到冒泡思想：给你一个数列，对相邻的两个个数进行比较，让大数下沉，或较小的数字进行上浮。若一次排序让大数和小数一并都找到，这样大大缩小了第一层的循环次数。——称为鸡尾酒排序。pos标记从哪个位置开始时，后面的数据都有顺序。prepos标记从哪个位置开始时，前面的数据都有顺序。 12345678910111213141516171819202122232425262728293031323334void BubbleSort(int arr[],int len)&#123; int tmp=0,flag=0,pos=0,k=len-1,prepos=0; for (int i=0;i&lt;len;i++)&#123; flag=0; pos=0; for(int j=i;j&lt;k;j++)&#123; if (arr[j]&gt;arr[j+1])&#123; tmp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=tmp; flag=1; pos=j; &#125; &#125; if (flag==0)&#123; return; &#125; k=pos; flag=0; for (int j=k;j&gt;i;j--)&#123; if (arr[j]&lt;arr[j-1])&#123; tmp=arr[j]; arr[j]=arr[j-1]; arr[j-1]=tmp; flag=1; prepos=j; &#125; &#125; if (flag==0)&#123; return; &#125; i=prepos-1; //由于i++操作，故需要进行减1操作，才能回到从哪个位置开始，前面都有序 &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://aemonswift.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"算法/排序","permalink":"http://aemonswift.github.io/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://aemonswift.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"hello","slug":"hello","date":"2019-10-21T12:01:35.000Z","updated":"2019-10-22T00:59:53.081Z","comments":true,"path":"2019/10/21/hello/","link":"","permalink":"http://aemonswift.github.io/2019/10/21/hello/","excerpt":"","text":"问题描述问题为什么重要问题目前解决方案有哪些问题的难点是什么你的创新点是什么问题求解问题数学描述问世间，何许人也！","categories":[{"name":"音乐","slug":"音乐","permalink":"http://aemonswift.github.io/categories/%E9%9F%B3%E4%B9%90/"},{"name":"前端","slug":"音乐/前端","permalink":"http://aemonswift.github.io/categories/%E9%9F%B3%E4%B9%90/%E5%89%8D%E7%AB%AF/"},{"name":"后端","slug":"音乐/前端/后端","permalink":"http://aemonswift.github.io/categories/%E9%9F%B3%E4%B9%90/%E5%89%8D%E7%AB%AF/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"古典","slug":"古典","permalink":"http://aemonswift.github.io/tags/%E5%8F%A4%E5%85%B8/"},{"name":"轻音乐","slug":"轻音乐","permalink":"http://aemonswift.github.io/tags/%E8%BD%BB%E9%9F%B3%E4%B9%90/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-10-21T00:53:07.676Z","updated":"2019-10-21T00:53:07.676Z","comments":true,"path":"2019/10/21/hello-world/","link":"","permalink":"http://aemonswift.github.io/2019/10/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}